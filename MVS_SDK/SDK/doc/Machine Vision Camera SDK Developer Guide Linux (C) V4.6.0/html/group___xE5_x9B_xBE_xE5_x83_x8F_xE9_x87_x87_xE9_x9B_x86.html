<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="custom-style.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
	<div style="overflow: hidden;">
		<div style="height: 57px;min-width: 1039px;background-size: auto 100%;background:url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABwgAAAABCAYAAADKO/rAAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAABRSURBVFhH7dUxCoBADEXB5LK5/w1iIaLIrsgWNs50Sf/4WVUd8HOZGd1nCqMbGNMPrNMPrJv1cvz0A3OjfuwPvDPrxf7A7t7IlX7gmX74VsQGguw4S6+UnSYAAAAASUVORK5CYII=');">
			<img src="titleleft.png" style="float: left;"/>
			<img src="titleright.png" alt="" style="float: right;" />
		</div>
	</div>
<!-- Generated by Doxygen 1.8.15 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Home&#160;Page</span></a></li>
      <li><a href="_xE5_x8F_x91_xE7_x89_x88_xE8_xAF_xB4_xE6_x98_x8E.html"><span>Release&#160;Notes</span></a></li>
      <li><a href="_xE7_x8E_xAF_xE5_xA2_x83_xE9_x85_x8D_xE7_xBD_xAE.html"><span>Envrionment&#160;Configuration</span></a></li>
      <li><a href="_xE7_xBC_x96_xE7_xA8_x8B_xE5_xBC_x95_xE5_xAF_xBC.html"><span>Programming&#160;Guide</span></a></li>
      <li class="current"><a href="modules.html"><span>API&#160;Reference</span></a></li>
      <li><a href="_xE7_x9B_xB8_xE6_x9C_xBA_xE5_x8F_x82_xE6_x95_xB0_xE8_x8A_x82_xE7_x82_xB9_xE8_xA1_xA8.html"><span>Camera&#160;Parameter&#160;Node&#160;Table</span></a></li>
      <li><a href="_xE7_xA4_xBA_xE4_xBE_x8B_xE7_xA8_x8B_xE5_xBA_x8F_xE6_xA6_x82_xE8_xA7_x88.html"><span>Samples</span></a></li>
      <li><a href="_xE5_xB8_xB8_xE8_xA7_x81_xE9_x97_xAE_xE9_xA2_x98.html"><span>FAQs</span></a></li>
      <li><a href="_xE6_xB3_x95_xE5_xBE_x8B_xE5_xA3_xB0_xE6_x98_x8E.html"><span>Disclaimer</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Image Acquisition APIs</div>  </div>
</div><!--header-->
<div class="contents">

<p>Includes APIs for acquiring images (via polling or callback function), starting and stopping image grabbing, etc.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga367fa35568b2bb6a22c98354c32ff3c7"><td class="memItemLeft" align="right" valign="top">MV_CAMCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga367fa35568b2bb6a22c98354c32ff3c7">MV_CC_RegisterImageCallBackEx</a> (IN void *<a class="el" href="_image_save_8cpp.html#a81011b79683fab64ce3aff71114f8fdd">handle</a>, IN <a class="el" href="group___xE5_x9B_x9E_xE8_xB0_x83_xE5_x87_xBD_xE6_x95_xB0_xE5_xAE_x9A_xE4_xB9_x89.html#ga4a622b22dad718cefe70592212171276">MvImageCallbackEx</a> cbOutput, IN void *pUser)</td></tr>
<tr class="memdesc:ga367fa35568b2bb6a22c98354c32ff3c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers an image data callback (extended API 1).  <a href="#ga367fa35568b2bb6a22c98354c32ff3c7">More...</a><br /></td></tr>
<tr class="separator:ga367fa35568b2bb6a22c98354c32ff3c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0847c2bcdbc152d4e43df9cee28c3989"><td class="memItemLeft" align="right" valign="top">MV_CAMCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga0847c2bcdbc152d4e43df9cee28c3989">MV_CC_RegisterImageCallBackEx2</a> (IN void *<a class="el" href="_image_save_8cpp.html#a81011b79683fab64ce3aff71114f8fdd">handle</a>, IN <a class="el" href="group___xE5_x9B_x9E_xE8_xB0_x83_xE5_x87_xBD_xE6_x95_xB0_xE5_xAE_x9A_xE4_xB9_x89.html#gaad77d2dd2df483b53c1ef1ce0bfbc9c0">MvImageCallbackEx2</a> cbOutput, IN void *pUser, IN bool bAutoFree)</td></tr>
<tr class="memdesc:ga0847c2bcdbc152d4e43df9cee28c3989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers an image data callback (extended API 2).  <a href="#ga0847c2bcdbc152d4e43df9cee28c3989">More...</a><br /></td></tr>
<tr class="separator:ga0847c2bcdbc152d4e43df9cee28c3989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78728211c47c6f118110fde635d6ac69"><td class="memItemLeft" align="right" valign="top">MV_CAMCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga78728211c47c6f118110fde635d6ac69">MV_CC_StartGrabbing</a> (IN void *<a class="el" href="_image_save_8cpp.html#a81011b79683fab64ce3aff71114f8fdd">handle</a>)</td></tr>
<tr class="memdesc:ga78728211c47c6f118110fde635d6ac69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts image grabbing.  <a href="#ga78728211c47c6f118110fde635d6ac69">More...</a><br /></td></tr>
<tr class="separator:ga78728211c47c6f118110fde635d6ac69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5d7f4ae46a53851f104e26fa449ab06"><td class="memItemLeft" align="right" valign="top">MV_CAMCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#gae5d7f4ae46a53851f104e26fa449ab06">MV_CC_StopGrabbing</a> (IN void *<a class="el" href="_image_save_8cpp.html#a81011b79683fab64ce3aff71114f8fdd">handle</a>)</td></tr>
<tr class="memdesc:gae5d7f4ae46a53851f104e26fa449ab06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops image grabbing.  <a href="#gae5d7f4ae46a53851f104e26fa449ab06">More...</a><br /></td></tr>
<tr class="separator:gae5d7f4ae46a53851f104e26fa449ab06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33331585a4e2a64653b74af66157a6d8"><td class="memItemLeft" align="right" valign="top">MV_CAMCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga33331585a4e2a64653b74af66157a6d8">MV_CC_GetImageBuffer</a> (IN void *<a class="el" href="_image_save_8cpp.html#a81011b79683fab64ce3aff71114f8fdd">handle</a>, IN OUT <a class="el" href="struct_m_v___f_r_a_m_e___o_u_t.html">MV_FRAME_OUT</a> *pstFrame, IN unsigned int nMsec)</td></tr>
<tr class="memdesc:ga33331585a4e2a64653b74af66157a6d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets one frame of image using internal buffer. (This API cannot be used with <a class="el" href="group___xE5_xBA_x9F_xE5_xBC_x83_xE6_x8E_xA5_xE5_x8F_xA3.html#ga3d79377333891ab4f3e9ba352757eca7" title="Displays the image, registers the display window, and automatically display internally....">MV_CC_Display()</a> at the same time.)  <a href="#ga33331585a4e2a64653b74af66157a6d8">More...</a><br /></td></tr>
<tr class="separator:ga33331585a4e2a64653b74af66157a6d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeff416b2d35df148fa2e63521d8847d3"><td class="memItemLeft" align="right" valign="top">MV_CAMCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#gaeff416b2d35df148fa2e63521d8847d3">MV_CC_FreeImageBuffer</a> (IN void *<a class="el" href="_image_save_8cpp.html#a81011b79683fab64ce3aff71114f8fdd">handle</a>, IN <a class="el" href="struct_m_v___f_r_a_m_e___o_u_t.html">MV_FRAME_OUT</a> *pstFrame)</td></tr>
<tr class="memdesc:gaeff416b2d35df148fa2e63521d8847d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases image buffer. (This API is used to release the image buffer that is no longer used, and it is used with <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga33331585a4e2a64653b74af66157a6d8" title="Gets one frame of image using internal buffer. (This API cannot be used with MV_CC_Display() at the s...">MV_CC_GetImageBuffer()</a> in pairs.)  <a href="#gaeff416b2d35df148fa2e63521d8847d3">More...</a><br /></td></tr>
<tr class="separator:gaeff416b2d35df148fa2e63521d8847d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb284e0ae3eeced7e1f9395317800c6f"><td class="memItemLeft" align="right" valign="top">MV_CAMCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#gafb284e0ae3eeced7e1f9395317800c6f">MV_CC_GetOneFrameTimeout</a> (IN void *<a class="el" href="_image_save_8cpp.html#a81011b79683fab64ce3aff71114f8fdd">handle</a>, IN OUT unsigned char *pData, IN unsigned int nDataSize, IN OUT <a class="el" href="struct_m_v___f_r_a_m_e___o_u_t___i_n_f_o___e_x.html">MV_FRAME_OUT_INFO_EX</a> *pstFrameInfo, IN unsigned int nMsec)</td></tr>
<tr class="memdesc:gafb284e0ae3eeced7e1f9395317800c6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets one frame of image with timeout, and the SDK waits internally to return until data is available.  <a href="#gafb284e0ae3eeced7e1f9395317800c6f">More...</a><br /></td></tr>
<tr class="separator:gafb284e0ae3eeced7e1f9395317800c6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90fcfa3fb929d76e99ea7f5946d6c5ff"><td class="memItemLeft" align="right" valign="top">MV_CAMCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga90fcfa3fb929d76e99ea7f5946d6c5ff">MV_CC_ClearImageBuffer</a> (IN void *<a class="el" href="_image_save_8cpp.html#a81011b79683fab64ce3aff71114f8fdd">handle</a>)</td></tr>
<tr class="memdesc:ga90fcfa3fb929d76e99ea7f5946d6c5ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the image buffer.  <a href="#ga90fcfa3fb929d76e99ea7f5946d6c5ff">More...</a><br /></td></tr>
<tr class="separator:ga90fcfa3fb929d76e99ea7f5946d6c5ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68d7ec74d6c37907cb868f0ff7f9251e"><td class="memItemLeft" align="right" valign="top">MV_CAMCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga68d7ec74d6c37907cb868f0ff7f9251e">MV_CC_GetValidImageNum</a> (IN void *<a class="el" href="_image_save_8cpp.html#a81011b79683fab64ce3aff71114f8fdd">handle</a>, IN OUT unsigned int *pnValidImageNum)</td></tr>
<tr class="memdesc:ga68d7ec74d6c37907cb868f0ff7f9251e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of valid images in the current image buffer.  <a href="#ga68d7ec74d6c37907cb868f0ff7f9251e">More...</a><br /></td></tr>
<tr class="separator:ga68d7ec74d6c37907cb868f0ff7f9251e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2088ec54d617eb629412729e0241067d"><td class="memItemLeft" align="right" valign="top">MV_CAMCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga2088ec54d617eb629412729e0241067d">MV_CC_SetImageNodeNum</a> (IN void *<a class="el" href="_image_save_8cpp.html#a81011b79683fab64ce3aff71114f8fdd">handle</a>, IN unsigned int nNum)</td></tr>
<tr class="memdesc:ga2088ec54d617eb629412729e0241067d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of nodes for SDK internal image buffer. The value is no less than 1, and this API should be called before image grabbing.  <a href="#ga2088ec54d617eb629412729e0241067d">More...</a><br /></td></tr>
<tr class="separator:ga2088ec54d617eb629412729e0241067d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad337d46cc1955800d4650491ba66e9ce"><td class="memItemLeft" align="right" valign="top">MV_CAMCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#gad337d46cc1955800d4650491ba66e9ce">MV_CC_SetGrabStrategy</a> (IN void *<a class="el" href="_image_save_8cpp.html#a81011b79683fab64ce3aff71114f8fdd">handle</a>, IN <a class="el" href="group___xE6_x9E_x9A_xE4_xB8_xBE_xE7_xB1_xBB_xE5_x9E_x8B_xE5_xAE_x9A_xE4_xB9_x89.html#ga43a073efc6b120886a30b84c96cfa82c">MV_GRAB_STRATEGY</a> enGrabStrategy)</td></tr>
<tr class="memdesc:gad337d46cc1955800d4650491ba66e9ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets image grabbing strategy.  <a href="#gad337d46cc1955800d4650491ba66e9ce">More...</a><br /></td></tr>
<tr class="separator:gad337d46cc1955800d4650491ba66e9ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d2e6b554356853f307b50b0a0fc3dce"><td class="memItemLeft" align="right" valign="top">MV_CAMCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga2d2e6b554356853f307b50b0a0fc3dce">MV_CC_SetOutputQueueSize</a> (IN void *<a class="el" href="_image_save_8cpp.html#a81011b79683fab64ce3aff71114f8fdd">handle</a>, IN unsigned int nOutputQueueSize)</td></tr>
<tr class="memdesc:ga2d2e6b554356853f307b50b0a0fc3dce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of output buffers, range: [1, ImageNodeNum].  <a href="#ga2d2e6b554356853f307b50b0a0fc3dce">More...</a><br /></td></tr>
<tr class="separator:ga2d2e6b554356853f307b50b0a0fc3dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5030eb8498bb2baa031c6b6e8d03406"><td class="memItemLeft" align="right" valign="top">MV_CAMCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#gac5030eb8498bb2baa031c6b6e8d03406">MV_CC_GetPayloadSize</a> (IN void *<a class="el" href="_image_save_8cpp.html#a81011b79683fab64ce3aff71114f8fdd">handle</a>, IN OUT uint64_t *pnPayloadSize, IN OUT unsigned int *pnAlignment)</td></tr>
<tr class="memdesc:gac5030eb8498bb2baa031c6b6e8d03406"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the device payload size (including image data and Chunk data) and memory alignment method. It is used by the application layer to allocate sufficient buffer and correct memory alignment when registering external memory for SDK.  <a href="#gac5030eb8498bb2baa031c6b6e8d03406">More...</a><br /></td></tr>
<tr class="separator:gac5030eb8498bb2baa031c6b6e8d03406"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Includes APIs for acquiring images (via polling or callback function), starting and stopping image grabbing, etc. </p>
<p>Call image acquisition APIs to perform ISP algorithm processing on images via the configuration file generated by the ISP tool.<br />
Before using the ISP tool, an ISP plug-in library needs to be installed, and a folder named "ISPTool" needs to be created. In addition, the configuration files generated by camera connecting should be placed in folders named with the camera model or serial No., inside the ISPTool folder. To get the configuration file, please contact technical support. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga367fa35568b2bb6a22c98354c32ff3c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga367fa35568b2bb6a22c98354c32ff3c7">&#9670;&nbsp;</a></span>MV_CC_RegisterImageCallBackEx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_CAMCTRL_API int __stdcall MV_CC_RegisterImageCallBackEx </td>
          <td>(</td>
          <td class="paramtype">IN void *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN <a class="el" href="group___xE5_x9B_x9E_xE8_xB0_x83_xE5_x87_xBD_xE6_x95_xB0_xE5_xAE_x9A_xE4_xB9_x89.html#ga4a622b22dad718cefe70592212171276">MvImageCallbackEx</a>&#160;</td>
          <td class="paramname"><em>cbOutput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN void *&#160;</td>
          <td class="paramname"><em>pUser</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers an image data callback (extended API 1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[IN] It refers to the device handle. </td></tr>
    <tr><td class="paramname">cbOutput</td><td>[IN] It refers to the pointer to the callback function. </td></tr>
    <tr><td class="paramname">pUser</td><td>[IN] It refers to user-defined variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns MV_OK for success, and returns corresponding <a class="el" href="group___xE7_x8A_xB6_xE6_x80_x81_xE7_xA0_x81.html">Error Code</a> for failure. </dd></dl>
<dl class="section note"><dt>Note</dt><dd><b>&#160;&bull;&#160;</b>Before calling this API to register an image data callback, you should call the API <a class="el" href="group___xE7_x9B_xB8_xE6_x9C_xBA_xE5_x88_x9D_xE5_xA7_x8B_xE5_x8C_x96.html#gaf10f0644caa6d4dd39fd8c14f8736153" title="Creates a device handle.">MV_CC_CreateHandle()</a>. <br />
 <b>&#160;&bull;&#160;</b>There are two image acquisition methods, and the two methods cannot be used together. <br />
 <ol>
<li>
Method 1: Call <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga367fa35568b2bb6a22c98354c32ff3c7" title="Registers an image data callback (extended API 1).">MV_CC_RegisterImageCallBackEx()</a> to register an image data callback, and then call <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga78728211c47c6f118110fde635d6ac69" title="Starts image grabbing.">MV_CC_StartGrabbing()</a> to start image acquisition. The collected image data will be returned in the configured callback function. </li>
<li>
Method 2: Call <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga78728211c47c6f118110fde635d6ac69" title="Starts image grabbing.">MV_CC_StartGrabbing()</a> to start image acquisition, and the call <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#gafb284e0ae3eeced7e1f9395317800c6f" title="Gets one frame of image with timeout, and the SDK waits internally to return until data is available.">MV_CC_GetOneFrameTimeout()</a> repeatedly in application layer to get frame data in specified pixel format. When getting frame data, the upper application program should control the frequency of calling this API according to frame rate. </li>
</ol>
<b>&#160;&bull;&#160;</b>This API is not supported by devices with <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga45ee1f85623d2a6d3473f62f5cf90a77" title="Camera link device (serial port).">MV_CAMERALINK_DEVICE()</a>. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_parametrize_camera__area_scan_i_o_settings_8cpp-example.html#a53">ParametrizeCamera_AreaScanIOSettings.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ga0847c2bcdbc152d4e43df9cee28c3989"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0847c2bcdbc152d4e43df9cee28c3989">&#9670;&nbsp;</a></span>MV_CC_RegisterImageCallBackEx2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_CAMCTRL_API int __stdcall MV_CC_RegisterImageCallBackEx2 </td>
          <td>(</td>
          <td class="paramtype">IN void *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN <a class="el" href="group___xE5_x9B_x9E_xE8_xB0_x83_xE5_x87_xBD_xE6_x95_xB0_xE5_xAE_x9A_xE4_xB9_x89.html#gaad77d2dd2df483b53c1ef1ce0bfbc9c0">MvImageCallbackEx2</a>&#160;</td>
          <td class="paramname"><em>cbOutput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN void *&#160;</td>
          <td class="paramname"><em>pUser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN bool&#160;</td>
          <td class="paramname"><em>bAutoFree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers an image data callback (extended API 2). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[IN] It refers to the device handle. </td></tr>
    <tr><td class="paramname">cbOutput</td><td>[IN] It refers to the pointer to the callback function. </td></tr>
    <tr><td class="paramname">bAutoFree</td><td>[IN] It refers to the mark for automatic releasing of image buffer. <ul>
<li>true: The image buffer will be released and reused by SDK after callback. </li>
<li>false: After callback, it is required to call <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#gaeff416b2d35df148fa2e63521d8847d3" title="Releases image buffer. (This API is used to release the image buffer that is no longer used,...">MV_CC_FreeImageBuffer()</a> to release and reuse the image buffer. </li>
</ul>
</td></tr>
    <tr><td class="paramname">pUser</td><td>[IN] It refers to the user-defined variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns MV_OK for success, and returns corresponding <a class="el" href="group___xE7_x8A_xB6_xE6_x80_x81_xE7_xA0_x81.html">Error Code</a> for failure. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>This API can be called after <a class="el" href="group___xE7_x9B_xB8_xE6_x9C_xBA_xE5_x88_x9D_xE5_xA7_x8B_xE5_x8C_x96.html#gaf10f0644caa6d4dd39fd8c14f8736153" title="Creates a device handle.">MV_CC_CreateHandle()</a> to register an image data callback. </li>
<li>This API is not supported by camera link devices. </li>
<li>This API and <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga367fa35568b2bb6a22c98354c32ff3c7" title="Registers an image data callback (extended API 1).">MV_CC_RegisterImageCallBackEx()</a> are mutually exclusive and should not be called interchangeably. </li>
<li>This API and APIs for getting images actively (such as <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga33331585a4e2a64653b74af66157a6d8" title="Gets one frame of image using internal buffer. (This API cannot be used with MV_CC_Display() at the s...">MV_CC_GetImageBuffer()</a> and <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#gafb284e0ae3eeced7e1f9395317800c6f" title="Gets one frame of image with timeout, and the SDK waits internally to return until data is available.">MV_CC_GetOneFrameTimeout()</a> ) are mutually exclusive. </li>
<li>The MV_FRAME_OUT* pstFrame in <a class="el" href="group___xE5_x9B_x9E_xE8_xB0_x83_xE5_x87_xBD_xE6_x95_xB0_xE5_xAE_x9A_xE4_xB9_x89.html#gaad77d2dd2df483b53c1ef1ce0bfbc9c0">MvImageCallbackEx2</a> is an internal variable of the SDK. If you need to use it outside the callback function, copy the data structure of pstFrame (there is no need to copy the image data). </li>
</ul>
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_events__interface_8cpp-example.html#a28">Events_Interface.cpp</a>, <a class="el" href="_grab__asynchronous_8cpp-example.html#a66">Grab_Asynchronous.cpp</a>, <a class="el" href="_interface_and_device_demo_8cpp-example.html#a28">InterfaceAndDeviceDemo.cpp</a>, <a class="el" href="_line_scan_software_trigger_8cpp-example.html#a30">LineScanSoftwareTrigger.cpp</a>, <a class="el" href="_parametrize_camera__line_scan_i_o_settings_8cpp-example.html#a56">ParametrizeCamera_LineScanIOSettings.cpp</a>, and <a class="el" href="_reconnect_demo_8cpp-example.html#a55">ReconnectDemo.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ga78728211c47c6f118110fde635d6ac69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78728211c47c6f118110fde635d6ac69">&#9670;&nbsp;</a></span>MV_CC_StartGrabbing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_CAMCTRL_API int __stdcall MV_CC_StartGrabbing </td>
          <td>(</td>
          <td class="paramtype">IN void *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts image grabbing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[IN] It refers to the device handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns MV_OK for success, and returns corresponding <a class="el" href="group___xE7_x8A_xB6_xE6_x80_x81_xE7_xA0_x81.html">Error Code</a> for failure. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API is not supported by camera link devices. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_chunk_data_8cpp-example.html#a64">ChunkData.cpp</a>, <a class="el" href="_connect_spec_camera_8cpp-example.html#a28">ConnectSpecCamera.cpp</a>, <a class="el" href="_display_8cpp-example.html#a63">Display.cpp</a>, <a class="el" href="_events_8cpp-example.html#a55">Events.cpp</a>, <a class="el" href="_events__interface_8cpp-example.html#a29">Events_Interface.cpp</a>, <a class="el" href="_grab__asynchronous_8cpp-example.html#a67">Grab_Asynchronous.cpp</a>, <a class="el" href="_grab_image_8cpp-example.html#a53">GrabImage.cpp</a>, <a class="el" href="_grab_image__high_performance_8cpp-example.html#a59">GrabImage_HighPerformance.cpp</a>, <a class="el" href="_grab_multiple_camera_8cpp-example.html#a58">GrabMultipleCamera.cpp</a>, <a class="el" href="_high_bandwidth_decode_8cpp-example.html#a86">HighBandwidthDecode.cpp</a>, <a class="el" href="_image_process_8cpp-example.html#a46">ImageProcess.cpp</a>, <a class="el" href="_image_save_8cpp-example.html#a111">ImageSave.cpp</a>, <a class="el" href="_interface_and_device_demo_8cpp-example.html#a30">InterfaceAndDeviceDemo.cpp</a>, <a class="el" href="_line_scan_software_trigger_8cpp-example.html#a31">LineScanSoftwareTrigger.cpp</a>, <a class="el" href="_multi_cast_8cpp-example.html#a60">MultiCast.cpp</a>, <a class="el" href="_multi_light_ctrl__image_stitching_8cpp-example.html#a89">MultiLightCtrl_ImageStitching.cpp</a>, <a class="el" href="_parametrize_camera__area_scan_i_o_settings_8cpp-example.html#a54">ParametrizeCamera_AreaScanIOSettings.cpp</a>, <a class="el" href="_parametrize_camera__line_scan_i_o_settings_8cpp-example.html#a57">ParametrizeCamera_LineScanIOSettings.cpp</a>, <a class="el" href="_quick_software_trigger_8cpp-example.html#a55">QuickSoftwareTrigger.cpp</a>, <a class="el" href="_reconnect_demo_8cpp-example.html#a56">ReconnectDemo.cpp</a>, and <a class="el" href="_trigger__image_8cpp-example.html#a56">Trigger_Image.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="gae5d7f4ae46a53851f104e26fa449ab06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5d7f4ae46a53851f104e26fa449ab06">&#9670;&nbsp;</a></span>MV_CC_StopGrabbing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_CAMCTRL_API int __stdcall MV_CC_StopGrabbing </td>
          <td>(</td>
          <td class="paramtype">IN void *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stops image grabbing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[IN] It refers to the device handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns MV_OK for success, and returns corresponding <a class="el" href="group___xE7_x8A_xB6_xE6_x80_x81_xE7_xA0_x81.html">Error Code</a> for failure. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API is not supported by camera link devices. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_chunk_data_8cpp-example.html#a65">ChunkData.cpp</a>, <a class="el" href="_connect_spec_camera_8cpp-example.html#a29">ConnectSpecCamera.cpp</a>, <a class="el" href="_display_8cpp-example.html#a64">Display.cpp</a>, <a class="el" href="_events_8cpp-example.html#a56">Events.cpp</a>, <a class="el" href="_events__interface_8cpp-example.html#a30">Events_Interface.cpp</a>, <a class="el" href="_grab__asynchronous_8cpp-example.html#a68">Grab_Asynchronous.cpp</a>, <a class="el" href="_grab_image_8cpp-example.html#a54">GrabImage.cpp</a>, <a class="el" href="_grab_image__high_performance_8cpp-example.html#a60">GrabImage_HighPerformance.cpp</a>, <a class="el" href="_grab_multiple_camera_8cpp-example.html#a59">GrabMultipleCamera.cpp</a>, <a class="el" href="_high_bandwidth_decode_8cpp-example.html#a107">HighBandwidthDecode.cpp</a>, <a class="el" href="_image_process_8cpp-example.html#a62">ImageProcess.cpp</a>, <a class="el" href="_image_save_8cpp-example.html#a124">ImageSave.cpp</a>, <a class="el" href="_interface_and_device_demo_8cpp-example.html#a31">InterfaceAndDeviceDemo.cpp</a>, <a class="el" href="_line_scan_software_trigger_8cpp-example.html#a32">LineScanSoftwareTrigger.cpp</a>, <a class="el" href="_multi_cast_8cpp-example.html#a61">MultiCast.cpp</a>, <a class="el" href="_multi_light_ctrl__image_stitching_8cpp-example.html#a138">MultiLightCtrl_ImageStitching.cpp</a>, <a class="el" href="_parametrize_camera__area_scan_i_o_settings_8cpp-example.html#a55">ParametrizeCamera_AreaScanIOSettings.cpp</a>, <a class="el" href="_parametrize_camera__line_scan_i_o_settings_8cpp-example.html#a58">ParametrizeCamera_LineScanIOSettings.cpp</a>, <a class="el" href="_quick_software_trigger_8cpp-example.html#a56">QuickSoftwareTrigger.cpp</a>, and <a class="el" href="_trigger__image_8cpp-example.html#a57">Trigger_Image.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ga33331585a4e2a64653b74af66157a6d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33331585a4e2a64653b74af66157a6d8">&#9670;&nbsp;</a></span>MV_CC_GetImageBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_CAMCTRL_API int __stdcall MV_CC_GetImageBuffer </td>
          <td>(</td>
          <td class="paramtype">IN void *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN OUT <a class="el" href="struct_m_v___f_r_a_m_e___o_u_t.html">MV_FRAME_OUT</a> *&#160;</td>
          <td class="paramname"><em>pstFrame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN unsigned int&#160;</td>
          <td class="paramname"><em>nMsec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets one frame of image using internal buffer. (This API cannot be used with <a class="el" href="group___xE5_xBA_x9F_xE5_xBC_x83_xE6_x8E_xA5_xE5_x8F_xA3.html#ga3d79377333891ab4f3e9ba352757eca7" title="Displays the image, registers the display window, and automatically display internally....">MV_CC_Display()</a> at the same time.) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[IN] It refers to the device handle. </td></tr>
    <tr><td class="paramname">pstFrame</td><td>[IN][OUT] It refers to image data and information. </td></tr>
    <tr><td class="paramname">nMsec</td><td>[IN] It refers to the timeout duration, unit: millisecond. You can input INFINITE to set unlimited timeout duration, and image grabbing will not stop until a frame of data is received or the image grabbing is manually stopped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns MV_OK for success, and returns corresponding <a class="el" href="group___xE7_x8A_xB6_xE6_x80_x81_xE7_xA0_x81.html">Error Code</a> for failure. </dd></dl>
<dl class="section note"><dt>Note</dt><dd><b>&#160;&bull;&#160;</b>Before calling this API to get image data frame, call <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga78728211c47c6f118110fde635d6ac69" title="Starts image grabbing.">MV_CC_StartGrabbing()</a> to start image acquisition. This API can get frame data actively, and the upper application program should control the frequency of calling this API according to the frame rate. This API supports setting timeout duration for receiving image data frames, which helps ensure stable image acquisition. It is applicable to scenes with high-stability requirement for getting images. <br />
 <b>&#160;&bull;&#160;</b>This API and <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#gaeff416b2d35df148fa2e63521d8847d3" title="Releases image buffer. (This API is used to release the image buffer that is no longer used,...">MV_CC_FreeImageBuffer()</a> should be called in pairs, after processing the acquired data, you should call <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#gaeff416b2d35df148fa2e63521d8847d3" title="Releases image buffer. (This API is used to release the image buffer that is no longer used,...">MV_CC_FreeImageBuffer()</a> to release the data pointer permission of pstFrame. <br />
 <b>&#160;&bull;&#160;</b>This API's image buffer is allocated by the SDK internally, so it has higher image acquisition efficiency than <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#gafb284e0ae3eeced7e1f9395317800c6f" title="Gets one frame of image with timeout, and the SDK waits internally to return until data is available.">MV_CC_GetOneFrameTimeout()</a> , whose image buffer needs to be manually allocated by the user. <br />
 <b>&#160;&bull;&#160;</b>This API cannot be called to grab images after calling <a class="el" href="group___xE5_xBA_x9F_xE5_xBC_x83_xE6_x8E_xA5_xE5_x8F_xA3.html#ga3d79377333891ab4f3e9ba352757eca7" title="Displays the image, registers the display window, and automatically display internally....">MV_CC_Display()</a>. <br />
 <b>&#160;&bull;&#160;</b>This API is supported by both USB3 vision devices and GigE devices. <br />
 <b>&#160;&bull;&#160;</b>This API is not supported by camera link devices. <br />
</dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_chunk_data_8cpp-example.html#a36">ChunkData.cpp</a>, <a class="el" href="_connect_spec_camera_8cpp-example.html#a5">ConnectSpecCamera.cpp</a>, <a class="el" href="_display_8cpp-example.html#a37">Display.cpp</a>, <a class="el" href="_grab_image_8cpp-example.html#a35">GrabImage.cpp</a>, <a class="el" href="_grab_image__high_performance_8cpp-example.html#a37">GrabImage_HighPerformance.cpp</a>, <a class="el" href="_grab_multiple_camera_8cpp-example.html#a38">GrabMultipleCamera.cpp</a>, <a class="el" href="_high_bandwidth_decode_8cpp-example.html#a90">HighBandwidthDecode.cpp</a>, <a class="el" href="_image_process_8cpp-example.html#a48">ImageProcess.cpp</a>, <a class="el" href="_image_save_8cpp-example.html#a113">ImageSave.cpp</a>, <a class="el" href="_multi_cast_8cpp-example.html#a35">MultiCast.cpp</a>, <a class="el" href="_multi_light_ctrl__image_stitching_8cpp-example.html#a93">MultiLightCtrl_ImageStitching.cpp</a>, <a class="el" href="_quick_software_trigger_8cpp-example.html#a26">QuickSoftwareTrigger.cpp</a>, and <a class="el" href="_trigger__image_8cpp-example.html#a36">Trigger_Image.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="gaeff416b2d35df148fa2e63521d8847d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeff416b2d35df148fa2e63521d8847d3">&#9670;&nbsp;</a></span>MV_CC_FreeImageBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_CAMCTRL_API int __stdcall MV_CC_FreeImageBuffer </td>
          <td>(</td>
          <td class="paramtype">IN void *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN <a class="el" href="struct_m_v___f_r_a_m_e___o_u_t.html">MV_FRAME_OUT</a> *&#160;</td>
          <td class="paramname"><em>pstFrame</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases image buffer. (This API is used to release the image buffer that is no longer used, and it is used with <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga33331585a4e2a64653b74af66157a6d8" title="Gets one frame of image using internal buffer. (This API cannot be used with MV_CC_Display() at the s...">MV_CC_GetImageBuffer()</a> in pairs.) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[IN] It refers to the device handle. </td></tr>
    <tr><td class="paramname">pstFrame</td><td>[IN][OUT] It refers to image data and information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns MV_OK for success, and returns corresponding <a class="el" href="group___xE7_x8A_xB6_xE6_x80_x81_xE7_xA0_x81.html">Error Code</a> for failure. </dd></dl>
<dl class="section note"><dt>Note</dt><dd><b>&#160;&bull;&#160;</b>This API and <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga33331585a4e2a64653b74af66157a6d8" title="Gets one frame of image using internal buffer. (This API cannot be used with MV_CC_Display() at the s...">MV_CC_GetImageBuffer()</a> should be called in pairs. After calling <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga33331585a4e2a64653b74af66157a6d8" title="Gets one frame of image using internal buffer. (This API cannot be used with MV_CC_Display() at the s...">MV_CC_GetImageBuffer()</a> to get image data pstFrame, call <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#gaeff416b2d35df148fa2e63521d8847d3" title="Releases image buffer. (This API is used to release the image buffer that is no longer used,...">MV_CC_FreeImageBuffer()</a> to release the permission. <br />
 <b>&#160;&bull;&#160;</b>This API has higher efficiency of image acquisition than the API <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#gafb284e0ae3eeced7e1f9395317800c6f" title="Gets one frame of image with timeout, and the SDK waits internally to return until data is available.">MV_CC_GetOneFrameTimeout()</a>. The max. number of nodes that can be outputted by <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga33331585a4e2a64653b74af66157a6d8" title="Gets one frame of image using internal buffer. (This API cannot be used with MV_CC_Display() at the s...">MV_CC_GetImageBuffer()</a>(without freeing the buffer) is the same as the "nNum" set by the API <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga2088ec54d617eb629412729e0241067d" title="Sets the number of nodes for SDK internal image buffer. The value is no less than 1,...">MV_CC_SetImageNodeNum()</a>, and the default value is 1. <br />
 <b>&#160;&bull;&#160;</b>This API is supported by both USB3 vision devices and GigE devices. <br />
 <b>&#160;&bull;&#160;</b>This API is not supported by camera link devices. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_chunk_data_8cpp-example.html#a49">ChunkData.cpp</a>, <a class="el" href="_connect_spec_camera_8cpp-example.html#a10">ConnectSpecCamera.cpp</a>, <a class="el" href="_display_8cpp-example.html#a50">Display.cpp</a>, <a class="el" href="_events__interface_8cpp-example.html#a78">Events_Interface.cpp</a>, <a class="el" href="_grab__asynchronous_8cpp-example.html#a46">Grab_Asynchronous.cpp</a>, <a class="el" href="_grab_image_8cpp-example.html#a40">GrabImage.cpp</a>, <a class="el" href="_grab_image__high_performance_8cpp-example.html#a43">GrabImage_HighPerformance.cpp</a>, <a class="el" href="_grab_multiple_camera_8cpp-example.html#a43">GrabMultipleCamera.cpp</a>, <a class="el" href="_high_bandwidth_decode_8cpp-example.html#a96">HighBandwidthDecode.cpp</a>, <a class="el" href="_image_process_8cpp-example.html#a61">ImageProcess.cpp</a>, <a class="el" href="_image_save_8cpp-example.html#a123">ImageSave.cpp</a>, <a class="el" href="_interface_and_device_demo_8cpp-example.html#a73">InterfaceAndDeviceDemo.cpp</a>, <a class="el" href="_line_scan_software_trigger_8cpp-example.html#a63">LineScanSoftwareTrigger.cpp</a>, <a class="el" href="_multi_cast_8cpp-example.html#a40">MultiCast.cpp</a>, <a class="el" href="_multi_light_ctrl__image_stitching_8cpp-example.html#a137">MultiLightCtrl_ImageStitching.cpp</a>, <a class="el" href="_parametrize_camera__line_scan_i_o_settings_8cpp-example.html#a40">ParametrizeCamera_LineScanIOSettings.cpp</a>, <a class="el" href="_quick_software_trigger_8cpp-example.html#a31">QuickSoftwareTrigger.cpp</a>, <a class="el" href="_reconnect_demo_8cpp-example.html#a41">ReconnectDemo.cpp</a>, and <a class="el" href="_trigger__image_8cpp-example.html#a41">Trigger_Image.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="gafb284e0ae3eeced7e1f9395317800c6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb284e0ae3eeced7e1f9395317800c6f">&#9670;&nbsp;</a></span>MV_CC_GetOneFrameTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_CAMCTRL_API int __stdcall MV_CC_GetOneFrameTimeout </td>
          <td>(</td>
          <td class="paramtype">IN void *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN OUT unsigned char *&#160;</td>
          <td class="paramname"><em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN unsigned int&#160;</td>
          <td class="paramname"><em>nDataSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN OUT <a class="el" href="struct_m_v___f_r_a_m_e___o_u_t___i_n_f_o___e_x.html">MV_FRAME_OUT_INFO_EX</a> *&#160;</td>
          <td class="paramname"><em>pstFrameInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN unsigned int&#160;</td>
          <td class="paramname"><em>nMsec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets one frame of image with timeout, and the SDK waits internally to return until data is available. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[IN] It refers to the device handle. </td></tr>
    <tr><td class="paramname">pData</td><td>[IN][OUT] It refers to the pointer to receive image data. </td></tr>
    <tr><td class="paramname">nDataSize</td><td>[IN] It refers to received buffer size. </td></tr>
    <tr><td class="paramname">pstFrameInfo</td><td>[IN][OUT] It refers to the structure of image information. </td></tr>
    <tr><td class="paramname">nMsec</td><td>[IN] It refers to timeout duration. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns MV_OK for success, and returns corresponding <a class="el" href="group___xE7_x8A_xB6_xE6_x80_x81_xE7_xA0_x81.html">Error Code</a> for failure. </dd></dl>
<dl class="section note"><dt>Note</dt><dd><b>&#160;&bull;&#160;</b>Before calling this API to get image data frame, call <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga78728211c47c6f118110fde635d6ac69" title="Starts image grabbing.">MV_CC_StartGrabbing()</a> to start image acquisition. This API can get frame data actively, and the upper application program should control the frequency of calling this API according to the frame rate. This API supports setting timeout duration for receiving image data frames, which helps ensure stable image acquisition. It is applicable to scenes with high-stability requirement for getting images. <br />
 <b>&#160;&bull;&#160;</b>This API is supported by both USB3 vision devices and GigE devices.<br />
 <b>&#160;&bull;&#160;</b>This API is not supported by camera link devices. </dd></dl>

</div>
</div>
<a id="ga90fcfa3fb929d76e99ea7f5946d6c5ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90fcfa3fb929d76e99ea7f5946d6c5ff">&#9670;&nbsp;</a></span>MV_CC_ClearImageBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_CAMCTRL_API int __stdcall MV_CC_ClearImageBuffer </td>
          <td>(</td>
          <td class="paramtype">IN void *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the image buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[IN] It refers to the device handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns MV_OK for success, and returns corresponding <a class="el" href="group___xE7_x8A_xB6_xE6_x80_x81_xE7_xA0_x81.html">Error Code</a> for failure. </dd></dl>
<dl class="section note"><dt>Note</dt><dd><b>&#160;&bull;&#160;</b>Call this API to clear the images you do not need in the buffer when the streaming is in progress. <br />
 <b>&#160;&bull;&#160;</b>After switching to trigger mode from continuous mode, you can call this API to clear historical data buffer. <br />
 <b>&#160;&bull;&#160;</b>Call this API to clear internal image buffer of SDK. The clearing of the buffer inside the frame grabbers is not supported. </dd></dl>

</div>
</div>
<a id="ga68d7ec74d6c37907cb868f0ff7f9251e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68d7ec74d6c37907cb868f0ff7f9251e">&#9670;&nbsp;</a></span>MV_CC_GetValidImageNum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_CAMCTRL_API int __stdcall MV_CC_GetValidImageNum </td>
          <td>(</td>
          <td class="paramtype">IN void *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN OUT unsigned int *&#160;</td>
          <td class="paramname"><em>pnValidImageNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of valid images in the current image buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[IN] It refers to the device handle. </td></tr>
    <tr><td class="paramname">pnValidImageNum</td><td>[IN][OUT] It refers to the pointer to the number of valid images in the current image buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns MV_OK for success, and returns corresponding <a class="el" href="group___xE7_x8A_xB6_xE6_x80_x81_xE7_xA0_x81.html">Error Code</a> for failure. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API can only be called to get the number of valid images in the SDK, not the number of those in frame grabbers. </dd></dl>

</div>
</div>
<a id="ga2088ec54d617eb629412729e0241067d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2088ec54d617eb629412729e0241067d">&#9670;&nbsp;</a></span>MV_CC_SetImageNodeNum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_CAMCTRL_API int __stdcall MV_CC_SetImageNodeNum </td>
          <td>(</td>
          <td class="paramtype">IN void *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN unsigned int&#160;</td>
          <td class="paramname"><em>nNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the number of nodes for SDK internal image buffer. The value is no less than 1, and this API should be called before image grabbing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[IN] It refers to the device handle. </td></tr>
    <tr><td class="paramname">nNum</td><td>[IN] It refers to the number of buffer nodes, which cannot be less than 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns MV_OK for success, and returns corresponding <a class="el" href="group___xE7_x8A_xB6_xE6_x80_x81_xE7_xA0_x81.html">Error Code</a> for failure. </dd></dl>
<dl class="section note"><dt>Note</dt><dd><b>&#160;&bull;&#160;</b>Call this API before <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga78728211c47c6f118110fde635d6ac69" title="Starts image grabbing.">MV_CC_StartGrabbing()</a> to set the number of nodes for SDK internal image buffer. <br />
 <b>&#160;&bull;&#160;</b>Image grabbing methods vary from different camera types. If this API is not called, the default number of buffer nodes will be different. For example, a camera with two USB interfaces has 3 buffer nodes by default. <br />
 <b>&#160;&bull;&#160;</b>The number of SDK allocated nodes = the pre-allocated nodes within SDK + the nodes allocated via this API. </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>If the memory allocated by the system is insufficient, the pre-allocated node number for SDK will be calculated again, and the actual allocated node number will be set to the latest pre-allocated node number.</dd></dl>
<p><b>&#160;&bull;&#160;</b>This API is not supported by camera link devices. For camera link devices, the buffer nodes can be connected and set via GenTL.<br />
 </p>

</div>
</div>
<a id="gad337d46cc1955800d4650491ba66e9ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad337d46cc1955800d4650491ba66e9ce">&#9670;&nbsp;</a></span>MV_CC_SetGrabStrategy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_CAMCTRL_API int __stdcall MV_CC_SetGrabStrategy </td>
          <td>(</td>
          <td class="paramtype">IN void *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN <a class="el" href="group___xE6_x9E_x9A_xE4_xB8_xBE_xE7_xB1_xBB_xE5_x9E_x8B_xE5_xAE_x9A_xE4_xB9_x89.html#ga43a073efc6b120886a30b84c96cfa82c">MV_GRAB_STRATEGY</a>&#160;</td>
          <td class="paramname"><em>enGrabStrategy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets image grabbing strategy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[IN] It refers to the device handle. </td></tr>
    <tr><td class="paramname">enGrabStrategy</td><td>[IN] It refers to strategy enumeration. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns MV_OK for success, and returns corresponding <a class="el" href="group___xE7_x8A_xB6_xE6_x80_x81_xE7_xA0_x81.html">Error Code</a> for failure. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>There are three defined image grabbing strategies, from which you can choose the suitable one according to the actual requirement. <ul>
<li>
OneByOne: Gets image frames one by one in chronological order. It is the default strategy. </li>
<li>
LatestImagesOnly: Only gets the latest one frame from the output buffer list, and clears the rest images in the list. </li>
<li>
LatestImages: Gets the latest image of OutputQueueSize frame from the output buffer list. The range of OutputQueueSize is between 1 and ImageNodeNum. If the OutputQueueSize value is set to 1, the strategy is same to LatestImagesOnly, and if the OutputQueueSize value is set to ImageNodeNum, the strategy is same to OneByOne. You can set the OutputQueueSize via API <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga2d2e6b554356853f307b50b0a0fc3dce" title="Sets the number of output buffers, range: [1, ImageNodeNum].">MV_CC_SetOutputQueueSize()</a>, and set the ImageNodeNum via API <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#ga2088ec54d617eb629412729e0241067d" title="Sets the number of nodes for SDK internal image buffer. The value is no less than 1,...">MV_CC_SetImageNodeNum()</a>. </li>
</ul>
</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>This API only supported by USB devices. <br />
</dd></dl>

</div>
</div>
<a id="ga2d2e6b554356853f307b50b0a0fc3dce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d2e6b554356853f307b50b0a0fc3dce">&#9670;&nbsp;</a></span>MV_CC_SetOutputQueueSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_CAMCTRL_API int __stdcall MV_CC_SetOutputQueueSize </td>
          <td>(</td>
          <td class="paramtype">IN void *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN unsigned int&#160;</td>
          <td class="paramname"><em>nOutputQueueSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the number of output buffers, range: [1, ImageNodeNum]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[IN] It refers to the device handle. </td></tr>
    <tr><td class="paramname">nOutputQueueSize</td><td>[IN] It refers to the number of output buffers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns MV_OK for success, and returns corresponding <a class="el" href="group___xE7_x8A_xB6_xE6_x80_x81_xE7_xA0_x81.html">Error Code</a> for failure. </dd></dl>
<dl class="section note"><dt>Note</dt><dd><b>&#160;&bull;&#160;</b>This API is valid only when <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86.html#gad337d46cc1955800d4650491ba66e9ce" title="Sets image grabbing strategy.">MV_CC_SetGrabStrategy()</a> is set to LatestImages. It is called to set the max. number of buffer images under the LatestImages strategy. You can adjust the number of output buffers during image grabbing. <br />
 <b>&#160;&bull;&#160;</b>For a camera with two USB interfaces, the value of nOutputQueueSize should be no less than 2. <br />
 <b>&#160;&bull;&#160;</b>This API is only supported by USB devices. <br />
</dd></dl>

</div>
</div>
<a id="gac5030eb8498bb2baa031c6b6e8d03406"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5030eb8498bb2baa031c6b6e8d03406">&#9670;&nbsp;</a></span>MV_CC_GetPayloadSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_CAMCTRL_API int __stdcall MV_CC_GetPayloadSize </td>
          <td>(</td>
          <td class="paramtype">IN void *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN OUT uint64_t *&#160;</td>
          <td class="paramname"><em>pnPayloadSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN OUT unsigned int *&#160;</td>
          <td class="paramname"><em>pnAlignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the device payload size (including image data and Chunk data) and memory alignment method. It is used by the application layer to allocate sufficient buffer and correct memory alignment when registering external memory for SDK. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[IN] It refers to the device handle. </td></tr>
    <tr><td class="paramname">pnPayloadSize</td><td>[IN][OUT] It refers to the payload size. </td></tr>
    <tr><td class="paramname">pnAlignment</td><td>[IN][OUT] It refers to alignment bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns MV_OK for success, and returns corresponding Error Code for failure. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<div class="footer" style="text-align: right;">
	<hr/>
	<small></small>
</div>
<script>
	// 
	var currentMenuItem = document.querySelector('.tablist > li.current > a')
	if (currentMenuItem) { // 
	  window.parent.postMessage({
		navHref: currentMenuItem.href
	  }, '*')
	} else {
	  window.parent.postMessage({
		url: window.location.href
	  }, '*')
	}
  </script>
</body>
</html>