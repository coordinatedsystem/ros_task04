<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="custom-style.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
	<div style="overflow: hidden;">
		<div style="height: 57px;min-width: 1039px;background-size: auto 100%;background:url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABwgAAAABCAYAAADKO/rAAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAABRSURBVFhH7dUxCoBADEXB5LK5/w1iIaLIrsgWNs50Sf/4WVUd8HOZGd1nCqMbGNMPrNMPrJv1cvz0A3OjfuwPvDPrxf7A7t7IlX7gmX74VsQGguw4S6+UnSYAAAAASUVORK5CYII=');">
			<img src="titleleft.png" style="float: left;"/>
			<img src="titleright.png" alt="" style="float: right;" />
		</div>
	</div>
<!-- Generated by Doxygen 1.8.15 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Home&#160;Page</span></a></li>
      <li><a href="_xE5_x8F_x91_xE7_x89_x88_xE8_xAF_xB4_xE6_x98_x8E.html"><span>Release&#160;Notes</span></a></li>
      <li><a href="_xE7_xBC_x96_xE7_xA8_x8B_xE5_xBC_x95_xE5_xAF_xBC.html"><span>Programming&#160;Guide</span></a></li>
      <li class="current"><a href="modules.html"><span>API&#160;Reference</span></a></li>
      <li><a href="_xE7_xA4_xBA_xE4_xBE_x8B_xE7_xA8_x8B_xE5_xBA_x8F_xE6_xA6_x82_xE8_xA7_x88.html"><span>Samples</span></a></li>
      <li><a href="_xE5_xB8_xB8_xE8_xA7_x81_xE9_x97_xAE_xE9_xA2_x98.html"><span>FAQs</span></a></li>
      <li><a href="_xE6_xB3_x95_xE5_xBE_x8B_xE5_xA3_xB0_xE6_x98_x8E.html"><span>Disclaimer</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Image Acquisition and Rendering</div>  </div>
</div><!--header-->
<div class="contents">

<p>Includes APIs for registering buffers, getting images, and rendering images.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaecc9206934d8184cc390b2b46c3269c8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE4_xB8_x8E_xE6_xB8_xB2_xE6_x9F_x93.html#gaecc9206934d8184cc390b2b46c3269c8">MV_CC_RegisterImageCallBackEx</a> (self, CallBackFun, pUser)</td></tr>
<tr class="memdesc:gaecc9206934d8184cc390b2b46c3269c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers an image data callback.  <a href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE4_xB8_x8E_xE6_xB8_xB2_xE6_x9F_x93.html#gaecc9206934d8184cc390b2b46c3269c8">More...</a><br /></td></tr>
<tr class="separator:gaecc9206934d8184cc390b2b46c3269c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b179a3ca778dfdf91fca21737069464"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE4_xB8_x8E_xE6_xB8_xB2_xE6_x9F_x93.html#ga2b179a3ca778dfdf91fca21737069464">MV_CC_RegisterImageCallBackEx2</a> (self, CallBackFun, pUser)</td></tr>
<tr class="memdesc:ga2b179a3ca778dfdf91fca21737069464"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers an image data callback.  <a href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE4_xB8_x8E_xE6_xB8_xB2_xE6_x9F_x93.html#ga2b179a3ca778dfdf91fca21737069464">More...</a><br /></td></tr>
<tr class="separator:ga2b179a3ca778dfdf91fca21737069464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga379f992aec0ddd3170b0ef0f5f2306d7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE4_xB8_x8E_xE6_xB8_xB2_xE6_x9F_x93.html#ga379f992aec0ddd3170b0ef0f5f2306d7">MV_CC_StartGrabbing</a> (self)</td></tr>
<tr class="memdesc:ga379f992aec0ddd3170b0ef0f5f2306d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts grabbing images.  <a href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE4_xB8_x8E_xE6_xB8_xB2_xE6_x9F_x93.html#ga379f992aec0ddd3170b0ef0f5f2306d7">More...</a><br /></td></tr>
<tr class="separator:ga379f992aec0ddd3170b0ef0f5f2306d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf3972a3a3b550f59d5d9ac88475139e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE4_xB8_x8E_xE6_xB8_xB2_xE6_x9F_x93.html#gadf3972a3a3b550f59d5d9ac88475139e">MV_CC_StopGrabbing</a> (self)</td></tr>
<tr class="memdesc:gadf3972a3a3b550f59d5d9ac88475139e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops grabbing images.  <a href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE4_xB8_x8E_xE6_xB8_xB2_xE6_x9F_x93.html#gadf3972a3a3b550f59d5d9ac88475139e">More...</a><br /></td></tr>
<tr class="separator:gadf3972a3a3b550f59d5d9ac88475139e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae49be0fa21399bad340b974b5ea89f57"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE4_xB8_x8E_xE6_xB8_xB2_xE6_x9F_x93.html#gae49be0fa21399bad340b974b5ea89f57">MV_CC_GetImageBuffer</a> (self, stFrame, nMsec)</td></tr>
<tr class="memdesc:gae49be0fa21399bad340b974b5ea89f57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets one frame of image using internal buffer.  <a href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE4_xB8_x8E_xE6_xB8_xB2_xE6_x9F_x93.html#gae49be0fa21399bad340b974b5ea89f57">More...</a><br /></td></tr>
<tr class="separator:gae49be0fa21399bad340b974b5ea89f57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b8f32c675cdec2a44c648ee76262e83"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE4_xB8_x8E_xE6_xB8_xB2_xE6_x9F_x93.html#ga6b8f32c675cdec2a44c648ee76262e83">MV_CC_FreeImageBuffer</a> (self, stFrame)</td></tr>
<tr class="memdesc:ga6b8f32c675cdec2a44c648ee76262e83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases image buffer.  <a href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE4_xB8_x8E_xE6_xB8_xB2_xE6_x9F_x93.html#ga6b8f32c675cdec2a44c648ee76262e83">More...</a><br /></td></tr>
<tr class="separator:ga6b8f32c675cdec2a44c648ee76262e83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88b55864ce5e20b7904581a6ccf1bd1a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE4_xB8_x8E_xE6_xB8_xB2_xE6_x9F_x93.html#ga88b55864ce5e20b7904581a6ccf1bd1a">MV_CC_GetOneFrameTimeout</a> (self, pData, nDataSize, stFrameInfo, nMsec=1000)</td></tr>
<tr class="memdesc:ga88b55864ce5e20b7904581a6ccf1bd1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets one frame of image with timeout, and the SDK waits internally to return until data is available.  <a href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE4_xB8_x8E_xE6_xB8_xB2_xE6_x9F_x93.html#ga88b55864ce5e20b7904581a6ccf1bd1a">More...</a><br /></td></tr>
<tr class="separator:ga88b55864ce5e20b7904581a6ccf1bd1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad65f79b5b6d2aea3e0411fe25dad3375"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE4_xB8_x8E_xE6_xB8_xB2_xE6_x9F_x93.html#gad65f79b5b6d2aea3e0411fe25dad3375">MV_CC_ClearImageBuffer</a> (self)</td></tr>
<tr class="memdesc:gad65f79b5b6d2aea3e0411fe25dad3375"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the image buffer.  <a href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE4_xB8_x8E_xE6_xB8_xB2_xE6_x9F_x93.html#gad65f79b5b6d2aea3e0411fe25dad3375">More...</a><br /></td></tr>
<tr class="separator:gad65f79b5b6d2aea3e0411fe25dad3375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9b94bbc70584799bba77ecca45a1b6d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE4_xB8_x8E_xE6_xB8_xB2_xE6_x9F_x93.html#gad9b94bbc70584799bba77ecca45a1b6d">MV_CC_GetValidImageNum</a> (self, nValidImageNum)</td></tr>
<tr class="memdesc:gad9b94bbc70584799bba77ecca45a1b6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of valid images in the current image buffer.  <a href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE4_xB8_x8E_xE6_xB8_xB2_xE6_x9F_x93.html#gad9b94bbc70584799bba77ecca45a1b6d">More...</a><br /></td></tr>
<tr class="separator:gad9b94bbc70584799bba77ecca45a1b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga538ee773fafb58ff292c0d837d8429ce"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE4_xB8_x8E_xE6_xB8_xB2_xE6_x9F_x93.html#ga538ee773fafb58ff292c0d837d8429ce">MV_CC_DisplayOneFrameEx</a> (self, hWnd, pstDisplayInfo)</td></tr>
<tr class="memdesc:ga538ee773fafb58ff292c0d837d8429ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Displays one frame of image (extended API 1).  <a href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE4_xB8_x8E_xE6_xB8_xB2_xE6_x9F_x93.html#ga538ee773fafb58ff292c0d837d8429ce">More...</a><br /></td></tr>
<tr class="separator:ga538ee773fafb58ff292c0d837d8429ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac04bec4e09806381bb2a25949ca90598"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE4_xB8_x8E_xE6_xB8_xB2_xE6_x9F_x93.html#gac04bec4e09806381bb2a25949ca90598">MV_CC_DisplayOneFrameEx2</a> (self, hWnd, pstImage, enRenderMode)</td></tr>
<tr class="memdesc:gac04bec4e09806381bb2a25949ca90598"><td class="mdescLeft">&#160;</td><td class="mdescRight">Displays one frame of image (extended API 2).  <a href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE4_xB8_x8E_xE6_xB8_xB2_xE6_x9F_x93.html#gac04bec4e09806381bb2a25949ca90598">More...</a><br /></td></tr>
<tr class="separator:gac04bec4e09806381bb2a25949ca90598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75a7ebe5f3c3bd038bf0dc52c23970ff"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE4_xB8_x8E_xE6_xB8_xB2_xE6_x9F_x93.html#ga75a7ebe5f3c3bd038bf0dc52c23970ff">MV_CC_SetImageNodeNum</a> (self, nNum)</td></tr>
<tr class="memdesc:ga75a7ebe5f3c3bd038bf0dc52c23970ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of nodes for SDK internal image buffer.  <a href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE4_xB8_x8E_xE6_xB8_xB2_xE6_x9F_x93.html#ga75a7ebe5f3c3bd038bf0dc52c23970ff">More...</a><br /></td></tr>
<tr class="separator:ga75a7ebe5f3c3bd038bf0dc52c23970ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d3eb2b366776ad42b34cf37bb7a23dc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE4_xB8_x8E_xE6_xB8_xB2_xE6_x9F_x93.html#ga0d3eb2b366776ad42b34cf37bb7a23dc">MV_CC_SetGrabStrategy</a> (self, enGrabStrategy)</td></tr>
<tr class="memdesc:ga0d3eb2b366776ad42b34cf37bb7a23dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the image grabbing strategy.  <a href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE4_xB8_x8E_xE6_xB8_xB2_xE6_x9F_x93.html#ga0d3eb2b366776ad42b34cf37bb7a23dc">More...</a><br /></td></tr>
<tr class="separator:ga0d3eb2b366776ad42b34cf37bb7a23dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4380d9e4d7f1c4b3d8941d693ace0385"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE4_xB8_x8E_xE6_xB8_xB2_xE6_x9F_x93.html#ga4380d9e4d7f1c4b3d8941d693ace0385">MV_CC_SetOutputQueueSize</a> (self, nOutputQueueSize)</td></tr>
<tr class="memdesc:ga4380d9e4d7f1c4b3d8941d693ace0385"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of output buffers, range: [1, ImageNodeNum].  <a href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE4_xB8_x8E_xE6_xB8_xB2_xE6_x9F_x93.html#ga4380d9e4d7f1c4b3d8941d693ace0385">More...</a><br /></td></tr>
<tr class="separator:ga4380d9e4d7f1c4b3d8941d693ace0385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4010b6ab34c4df5d69f7924426b3a520"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE4_xB8_x8E_xE6_xB8_xB2_xE6_x9F_x93.html#ga4010b6ab34c4df5d69f7924426b3a520">MV_CC_GetAllMatchInfo</a> (self, stInfo)</td></tr>
<tr class="memdesc:ga4010b6ab34c4df5d69f7924426b3a520"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the information of all types.  <a href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE4_xB8_x8E_xE6_xB8_xB2_xE6_x9F_x93.html#ga4010b6ab34c4df5d69f7924426b3a520">More...</a><br /></td></tr>
<tr class="separator:ga4010b6ab34c4df5d69f7924426b3a520"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Includes APIs for registering buffers, getting images, and rendering images. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaecc9206934d8184cc390b2b46c3269c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaecc9206934d8184cc390b2b46c3269c8">&#9670;&nbsp;</a></span>MV_CC_RegisterImageCallBackEx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def MvCameraControl_class.MV_CC_RegisterImageCallBackEx </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>CallBackFun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pUser</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers an image data callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[IN] It refers to the device handle. </td></tr>
    <tr><td class="paramname">cbOutput</td><td>[IN] It refers to the pointer to the callback function. </td></tr>
    <tr><td class="paramname">pUser</td><td>[IN] It refers to the user-defined variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns MV_OK for success, and returns corresponding <a class="el" href="group___xE7_x8A_xB6_xE6_x80_x81_xE7_xA0_x81.html">Error Code</a> for failure. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This API can be called after <a class="el" href="group___xE7_x9B_xB8_xE6_x9C_xBA_xE7_x9B_xB8_xE5_x85_xB3_xE9_x85_x8D_xE7_xBD_xAE.html#ga4b61f12ebd7ec3aead9687868c833c8c" title="Creates device handle.">MV_CC_CreateHandle()</a> to register an image data callback.<br />
 There are two image acquisition methods, and the two methods cannot be used together: <ul>
<li>Method 1: Call <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE4_xB8_x8E_xE6_xB8_xB2_xE6_x9F_x93.html#gaecc9206934d8184cc390b2b46c3269c8" title="Registers an image data callback.">MV_CC_RegisterImageCallBackEx()</a> to register an image data callback, and then call <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE4_xB8_x8E_xE6_xB8_xB2_xE6_x9F_x93.html#ga379f992aec0ddd3170b0ef0f5f2306d7" title="Starts grabbing images.">MV_CC_StartGrabbing()</a> to start image acquisition. The collected image data will be returned in the configured callback function. </li>
<li>Method 2: Call <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE4_xB8_x8E_xE6_xB8_xB2_xE6_x9F_x93.html#ga379f992aec0ddd3170b0ef0f5f2306d7" title="Starts grabbing images.">MV_CC_StartGrabbing()</a> to start image acquisition, and the call <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE4_xB8_x8E_xE6_xB8_xB2_xE6_x9F_x93.html#ga88b55864ce5e20b7904581a6ccf1bd1a" title="Gets one frame of image with timeout, and the SDK waits internally to return until data is available.">MV_CC_GetOneFrameTimeout()</a> repeatedly in application layer to get frame data in specified pixel format. </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>When getting frame data, the upper application program should control the frequency of calling this API according to frame rate. </li>
<li>This API is not supported by camera link devices. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga2b179a3ca778dfdf91fca21737069464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b179a3ca778dfdf91fca21737069464">&#9670;&nbsp;</a></span>MV_CC_RegisterImageCallBackEx2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def MvCameraControl_class.MV_CC_RegisterImageCallBackEx2 </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>CallBackFun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pUser</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers an image data callback. </p>
<p>After callback, you need to call <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE4_xB8_x8E_xE6_xB8_xB2_xE6_x9F_x93.html#ga6b8f32c675cdec2a44c648ee76262e83" title="Releases image buffer.">MV_CC_FreeImageBuffer()</a> to release image buffer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[IN] It refers to the device handle. </td></tr>
    <tr><td class="paramname">cbOutput</td><td>[IN] It refers to the pointer to the callback function. </td></tr>
    <tr><td class="paramname">pUser</td><td>[IN] It refers to the user-defined variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns MV_OK for success, and returns corresponding <a class="el" href="group___xE7_x8A_xB6_xE6_x80_x81_xE7_xA0_x81.html">Error Code</a> for failure. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This API can be called after <a class="el" href="group___xE7_x9B_xB8_xE6_x9C_xBA_xE7_x9B_xB8_xE5_x85_xB3_xE9_x85_x8D_xE7_xBD_xAE.html#ga4b61f12ebd7ec3aead9687868c833c8c" title="Creates device handle.">MV_CC_CreateHandle()</a> to register an image data callback. </dd></dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>When getting frame data, the upper application program should control the frequency of calling this API according to frame rate. </li>
<li>This API is not supported by camera link devices. </li>
<li>The parameter pstFrame in the callback function is a temporary variable within the SDK, and its contents should be copied before being used outside the image callback function. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga379f992aec0ddd3170b0ef0f5f2306d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga379f992aec0ddd3170b0ef0f5f2306d7">&#9670;&nbsp;</a></span>MV_CC_StartGrabbing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def MvCameraControl_class.MV_CC_StartGrabbing </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts grabbing images. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[IN] It refers to the device handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns MV_OK for success, and returns corresponding <a class="el" href="group___xE7_x8A_xB6_xE6_x80_x81_xE7_xA0_x81.html">Error Code</a> for failure. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This API is not supported by camera link devices. </dd></dl>

</div>
</div>
<a id="gadf3972a3a3b550f59d5d9ac88475139e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf3972a3a3b550f59d5d9ac88475139e">&#9670;&nbsp;</a></span>MV_CC_StopGrabbing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def MvCameraControl_class.MV_CC_StopGrabbing </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stops grabbing images. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[IN] It refers to the device handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns MV_OK for success, and returns corresponding <a class="el" href="group___xE7_x8A_xB6_xE6_x80_x81_xE7_xA0_x81.html">Error Code</a> for failure. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API is not supported by camera link devices. </dd></dl>

</div>
</div>
<a id="gae49be0fa21399bad340b974b5ea89f57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae49be0fa21399bad340b974b5ea89f57">&#9670;&nbsp;</a></span>MV_CC_GetImageBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def MvCameraControl_class.MV_CC_GetImageBuffer </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>stFrame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nMsec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets one frame of image using internal buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[IN] It refers to the device handle. </td></tr>
    <tr><td class="paramname">pstFrame</td><td>[IN][OUT] It refers to the image data and information. </td></tr>
    <tr><td class="paramname">nMsec</td><td>[IN] It refers to the timeout duration, unit: millisecond. You can input INFINITE to set unlimited timeout period, and image grabbing will not stop until a frame of data is received or the image grabbing is manually stopped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns MV_OK for success, and returns corresponding <a class="el" href="group___xE7_x8A_xB6_xE6_x80_x81_xE7_xA0_x81.html">Error Code</a> for failure. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>Before calling this API to get image data frame, call <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE4_xB8_x8E_xE6_xB8_xB2_xE6_x9F_x93.html#ga379f992aec0ddd3170b0ef0f5f2306d7" title="Starts grabbing images.">MV_CC_StartGrabbing()</a> to start image acquisition. This API can get frame data actively, and the upper application program should control the frequency of calling this API according to the frame rate.</li>
<li>This API supports setting timeout duration for receiving image data frames, which helps ensure stable image acquisition. It is applicable to scenes with high-stability requirement for getting images.</li>
<li>This API and <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE4_xB8_x8E_xE6_xB8_xB2_xE6_x9F_x93.html#ga6b8f32c675cdec2a44c648ee76262e83" title="Releases image buffer.">MV_CC_FreeImageBuffer()</a> should be called in pairs. After processing the acquired data, you should call <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE4_xB8_x8E_xE6_xB8_xB2_xE6_x9F_x93.html#ga6b8f32c675cdec2a44c648ee76262e83" title="Releases image buffer.">MV_CC_FreeImageBuffer()</a> to release the data pointer permission of pstFrame.</li>
<li>This API's image buffer is allocated by the SDK internally, so it has higher image acquisition efficiency than <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE4_xB8_x8E_xE6_xB8_xB2_xE6_x9F_x93.html#ga88b55864ce5e20b7904581a6ccf1bd1a" title="Gets one frame of image with timeout, and the SDK waits internally to return until data is available.">MV_CC_GetOneFrameTimeout()</a>, whose image buffer needs to be manually allocated by the user.</li>
<li>This API is supported by USB3 vision devices and GigE devices.</li>
<li>This API is not supported by camera link devices. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga6b8f32c675cdec2a44c648ee76262e83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b8f32c675cdec2a44c648ee76262e83">&#9670;&nbsp;</a></span>MV_CC_FreeImageBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def MvCameraControl_class.MV_CC_FreeImageBuffer </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>stFrame</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases image buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[IN] It refers to the device handle. </td></tr>
    <tr><td class="paramname">pstFrame</td><td>[IN] It refers to the image data and information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns MV_OK for success, and returns corresponding <a class="el" href="group___xE7_x8A_xB6_xE6_x80_x81_xE7_xA0_x81.html">Error Code</a> for failure. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>This API and <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE4_xB8_x8E_xE6_xB8_xB2_xE6_x9F_x93.html#gae49be0fa21399bad340b974b5ea89f57" title="Gets one frame of image using internal buffer.">MV_CC_GetImageBuffer()</a> should be called in pairs. After calling <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE4_xB8_x8E_xE6_xB8_xB2_xE6_x9F_x93.html#gae49be0fa21399bad340b974b5ea89f57" title="Gets one frame of image using internal buffer.">MV_CC_GetImageBuffer()</a> to get image data pFrame, call <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE4_xB8_x8E_xE6_xB8_xB2_xE6_x9F_x93.html#ga6b8f32c675cdec2a44c648ee76262e83" title="Releases image buffer.">MV_CC_FreeImageBuffer()</a> to release the permission.</li>
<li>This API has higher image acquisition efficiency than <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE4_xB8_x8E_xE6_xB8_xB2_xE6_x9F_x93.html#ga88b55864ce5e20b7904581a6ccf1bd1a" title="Gets one frame of image with timeout, and the SDK waits internally to return until data is available.">MV_CC_GetOneFrameTimeout()</a>.</li>
<li>If <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE4_xB8_x8E_xE6_xB8_xB2_xE6_x9F_x93.html#ga6b8f32c675cdec2a44c648ee76262e83" title="Releases image buffer.">MV_CC_FreeImageBuffer()</a> is not called after <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE4_xB8_x8E_xE6_xB8_xB2_xE6_x9F_x93.html#gae49be0fa21399bad340b974b5ea89f57" title="Gets one frame of image using internal buffer.">MV_CC_GetImageBuffer()</a>, the maximum number of output images is the number of SDK buffer nodes, and you can call <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE4_xB8_x8E_xE6_xB8_xB2_xE6_x9F_x93.html#ga75a7ebe5f3c3bd038bf0dc52c23970ff" title="Sets the number of nodes for SDK internal image buffer.">MV_CC_SetImageNodeNum()</a> to adjust the number of SDK buffers.</li>
<li>This API is supported by USB3 vision devices and GigE devices.</li>
<li>This API is not supported by camera link devices. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga88b55864ce5e20b7904581a6ccf1bd1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88b55864ce5e20b7904581a6ccf1bd1a">&#9670;&nbsp;</a></span>MV_CC_GetOneFrameTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def MvCameraControl_class.MV_CC_GetOneFrameTimeout </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nDataSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>stFrameInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nMsec</em> = <code>1000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets one frame of image with timeout, and the SDK waits internally to return until data is available. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[IN] It refers to the device handle. </td></tr>
    <tr><td class="paramname">pData</td><td>[IN][OUT] It refers to the pointer to image data buffer. </td></tr>
    <tr><td class="paramname">nDataSize</td><td>[IN] It refers to the receive buffer size. </td></tr>
    <tr><td class="paramname">pstFrameInfo</td><td>[IN][OUT] It refers to the structure of image information. </td></tr>
    <tr><td class="paramname">nMsec</td><td>[IN] It refers to the timeout duration, unit: millisecond. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns MV_OK for success, and returns corresponding <a class="el" href="group___xE7_x8A_xB6_xE6_x80_x81_xE7_xA0_x81.html">Error Code</a> for failure. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>Before calling this API to get image data frame, call <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE4_xB8_x8E_xE6_xB8_xB2_xE6_x9F_x93.html#ga379f992aec0ddd3170b0ef0f5f2306d7" title="Starts grabbing images.">MV_CC_StartGrabbing()</a> to start image acquisition.</li>
<li>This API can get frame data actively, and the upper application program should control the frequency of calling this API according to the frame rate.</li>
<li>This API supports setting timeout duration for receiving image data frames, which helps ensure stable image acquisition. It is applicable to scenes with high-stability requirement for getting images.</li>
<li>This API is supported by USB3 vision devices and GigE devices.</li>
<li>This API is not supported by camera link devices. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gad65f79b5b6d2aea3e0411fe25dad3375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad65f79b5b6d2aea3e0411fe25dad3375">&#9670;&nbsp;</a></span>MV_CC_ClearImageBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def MvCameraControl_class.MV_CC_ClearImageBuffer </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the image buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[IN] It refers to the device handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns MV_OK for success, and returns corresponding <a class="el" href="group___xE7_x8A_xB6_xE6_x80_x81_xE7_xA0_x81.html">Error Code</a> for failure. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>Call this API to clear the images you do not need in the buffer when the image grabbing is in progress.</li>
<li>After switching to trigger mode from continuous mode, you can call this API to clear historical data buffer.</li>
<li>This API can only be called to clear the image buffer within the SDK, and it cannot clear the buffer within the frame grabber. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gad9b94bbc70584799bba77ecca45a1b6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9b94bbc70584799bba77ecca45a1b6d">&#9670;&nbsp;</a></span>MV_CC_GetValidImageNum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def MvCameraControl_class.MV_CC_GetValidImageNum </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nValidImageNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of valid images in the current image buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[IN] It refers to the device handle. </td></tr>
    <tr><td class="paramname">pnValidImageNum</td><td>[IN][OUT] It refers to the pointer to the number of valid images in the current image buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns MV_OK for success, and returns corresponding <a class="el" href="group___xE7_x8A_xB6_xE6_x80_x81_xE7_xA0_x81.html">Error Code</a> for failure. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This API can only be called to get the number of valid images within the SDK, not the number of those in frame grabbers. </dd></dl>

</div>
</div>
<a id="ga538ee773fafb58ff292c0d837d8429ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga538ee773fafb58ff292c0d837d8429ce">&#9670;&nbsp;</a></span>MV_CC_DisplayOneFrameEx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def MvCameraControl_class.MV_CC_DisplayOneFrameEx </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>hWnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pstDisplayInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Displays one frame of image (extended API 1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[IN] It refers to the device handle. </td></tr>
    <tr><td class="paramname">hWnd</td><td>[IN] It refers to the window handle. </td></tr>
    <tr><td class="paramname">pstDisplayInfo</td><td>[IN] It refers to the image information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns MV_OK for success, and returns corresponding <a class="el" href="group___xE7_x8A_xB6_xE6_x80_x81_xE7_xA0_x81.html">Error Code</a> for failure. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>This API supports converting image width and image height to integer type data.</li>
<li>For rendering mode set to D3D, the maximum supported resolution is 16384 × 163840. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gac04bec4e09806381bb2a25949ca90598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac04bec4e09806381bb2a25949ca90598">&#9670;&nbsp;</a></span>MV_CC_DisplayOneFrameEx2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def MvCameraControl_class.MV_CC_DisplayOneFrameEx2 </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>hWnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pstImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>enRenderMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Displays one frame of image (extended API 2). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[IN] It refers to the device handle. </td></tr>
    <tr><td class="paramname">hWnd</td><td>[IN] It refers to the window handle. </td></tr>
    <tr><td class="paramname">pstImage</td><td>[IN] It refers to the image information. </td></tr>
    <tr><td class="paramname">enRenderMode</td><td>[IN] It refers to the image rendering mode. 0: OpenGL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns MV_OK for success, and returns corresponding <a class="el" href="group___xE7_x8A_xB6_xE6_x80_x81_xE7_xA0_x81.html">Error Code</a> for failure. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>This API supports rendering of images over 4 GB by entering nImageLen value of structure MV_CC_IMAGE .</li>
<li>The D3D mode and OpenGL mode are suitable for computers with a graphics card driver and the memory of the graphics card is greater than 1 GB. In this mode, the image effect of the client preview is better than that in the GDI mode.</li>
<li>For D3D rendering mode, the maximum supported resolution is 16384 × 163840.</li>
<li>For images over 4 GB, only OpenGL rendering mode is supported for image in pixel format including PixelType_Gvsp_RGB8_Packed, PixelType_Gvsp_BGR8_Packed, and PixelType_Gvsp_Mono8. In other rendering modes, images over 4 GB cannot be rendered.</li>
<li>For images under 4 GB, the image width and image height can be converted to integer type data. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga75a7ebe5f3c3bd038bf0dc52c23970ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga75a7ebe5f3c3bd038bf0dc52c23970ff">&#9670;&nbsp;</a></span>MV_CC_SetImageNodeNum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def MvCameraControl_class.MV_CC_SetImageNodeNum </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the number of nodes for SDK internal image buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[IN] It refers to the device handle. </td></tr>
    <tr><td class="paramname">pstImage</td><td>[IN] It refers to the number of buffer nodes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns MV_OK for success, and returns corresponding <a class="el" href="group___xE7_x8A_xB6_xE6_x80_x81_xE7_xA0_x81.html">Error Code</a> for failure. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>Call this API before <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE4_xB8_x8E_xE6_xB8_xB2_xE6_x9F_x93.html#ga379f992aec0ddd3170b0ef0f5f2306d7" title="Starts grabbing images.">MV_CC_StartGrabbing()</a> to set the number of nodes for SDK internal image buffer. The value is no less than 1. </li>
<li>Image grabbing methods vary from different camera types. If this API is not called, the default number of buffer nodes will be different. </li>
<li>The number of SDK allocated nodes = the pre-allocated nodes within SDK + the nodes allocated via this API. The nodes allocated via the API are only available within the SDK, for example, a camera with two USB interfaces has 2 more buffer nodes. If the memory allocated by the system is insufficient, the SDK will be calculated again, and the actual number of allocated nodes will be set to the number of latest pre-allocated nodes. </li>
<li>This API is not supported by camera link devices. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga0d3eb2b366776ad42b34cf37bb7a23dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d3eb2b366776ad42b34cf37bb7a23dc">&#9670;&nbsp;</a></span>MV_CC_SetGrabStrategy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def MvCameraControl_class.MV_CC_SetGrabStrategy </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>enGrabStrategy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the image grabbing strategy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[IN] It refers to the device handle. </td></tr>
    <tr><td class="paramname">enGrabStrategy</td><td>[IN] It refers to the strategy enumeration value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns MV_OK for success, and returns corresponding <a class="el" href="group___xE7_x8A_xB6_xE6_x80_x81_xE7_xA0_x81.html">Error Code</a> for failure. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>There are four defined image grabbing strategies, from which you can choose the suitable one according to the actual requirement. <ul>
<li>OneByOne: Gets image frames one by one in chronological order. It is the default strategy. </li>
<li>LatestImagesOnly: Only gets the latest one frame from the output buffer list, and clears the rest images in the list. </li>
<li>LatestImages: Gets the latest image of OutputQueueSize frame from the output buffer list. The range of OutputQueueSize is between 1 and ImageNodeNum. If the OutputQueueSize value is set to 1, the strategy is same to LatestImagesOnly, and if the OutputQueueSize value is set to ImageNodeNum, the strategy is same to OneByOne. You can set the OutputQueueSize via API <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE4_xB8_x8E_xE6_xB8_xB2_xE6_x9F_x93.html#ga4380d9e4d7f1c4b3d8941d693ace0385" title="Sets the number of output buffers, range: [1, ImageNodeNum].">MV_CC_SetOutputQueueSize()</a>, and set the ImageNodeNum via API <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE4_xB8_x8E_xE6_xB8_xB2_xE6_x9F_x93.html#ga75a7ebe5f3c3bd038bf0dc52c23970ff" title="Sets the number of nodes for SDK internal image buffer.">MV_CC_SetImageNodeNum()</a>. </li>
<li>UpcomingImage: Ignores all images in the output buffer list during calling image grabbing API (<a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE4_xB8_x8E_xE6_xB8_xB2_xE6_x9F_x93.html#ga88b55864ce5e20b7904581a6ccf1bd1a" title="Gets one frame of image with timeout, and the SDK waits internally to return until data is available.">MV_CC_GetOneFrameTimeout()</a> or <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE4_xB8_x8E_xE6_xB8_xB2_xE6_x9F_x93.html#gae49be0fa21399bad340b974b5ea89f57" title="Gets one frame of image using internal buffer.">MV_CC_GetImageBuffer()</a> ), and waits for the upcoming image generated by the device. </li>
</ul>
</dd>
<dd>
In Linux systems, this API is only available for USB devices. </dd></dl>

</div>
</div>
<a id="ga4380d9e4d7f1c4b3d8941d693ace0385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4380d9e4d7f1c4b3d8941d693ace0385">&#9670;&nbsp;</a></span>MV_CC_SetOutputQueueSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def MvCameraControl_class.MV_CC_SetOutputQueueSize </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nOutputQueueSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the number of output buffers, range: [1, ImageNodeNum]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[IN] It refers to the device handle. </td></tr>
    <tr><td class="paramname">nOutputQueueSize</td><td>[IN] It refers to the number of output buffers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns MV_OK for success, and returns corresponding <a class="el" href="group___xE7_x8A_xB6_xE6_x80_x81_xE7_xA0_x81.html">Error Code</a> for failure. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd><ul>
<li>This API is valid only when <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE4_xB8_x8E_xE6_xB8_xB2_xE6_x9F_x93.html#ga0d3eb2b366776ad42b34cf37bb7a23dc" title="Sets the image grabbing strategy.">MV_CC_SetGrabStrategy()</a> is set to LatestImages. It is called to set the maximum number of buffer images under the LatestImages strategy. You can adjust the number of output buffers during image grabbing. </li>
<li>In Linux systems, this API is only available for USB devices. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga4010b6ab34c4df5d69f7924426b3a520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4010b6ab34c4df5d69f7924426b3a520">&#9670;&nbsp;</a></span>MV_CC_GetAllMatchInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def MvCameraControl_class.MV_CC_GetAllMatchInfo </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>stInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the information of all types. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>[IN] It refers to the device handle. </td></tr>
    <tr><td class="paramname">pstInfo</td><td>[IN][OUT] It refers to the pointer to information structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns MV_OK for success, and returns corresponding <a class="el" href="group___xE7_x8A_xB6_xE6_x80_x81_xE7_xA0_x81.html">Error Code</a> for failure. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Input required information type (specify nType in structure MV_ALL_MATCH_INFO ), and get corresponding information (returned via pInfo in structure MV_ALL_MATCH_INFO ).<br />
 The precondition for calling the API depends on the obtained information type. <ul>
<li>To get the MV_MATCH_TYPE_NET_DETECT information (network traffic and packet loss) of GigE devices, call the API after <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE4_xB8_x8E_xE6_xB8_xB2_xE6_x9F_x93.html#ga379f992aec0ddd3170b0ef0f5f2306d7" title="Starts grabbing images.">MV_CC_StartGrabbing()</a>. </li>
<li>To get the MV_MATCH_TYPE_USB_DETECT information (total number of bytes received by host from USB3 vision device) of USB3 vision devices, call the API after <a class="el" href="group___xE7_x9B_xB8_xE6_x9C_xBA_xE7_x9B_xB8_xE5_x85_xB3_xE9_x85_x8D_xE7_xBD_xAE.html#gab24bcc2d36ffe7bdd0f54894ac7c35f1" title="Turns on the device.">MV_CC_OpenDevice()</a>.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This API is not supported by camera link devices. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<div class="footer" style="text-align: right;">
	<hr/>
	<small></small>
</div>
</body>
</html>