<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=GB2312"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="custom-style.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
	<div style="overflow: hidden;">
		<div style="height: 57px;min-width: 1039px;background-size: auto 100%;background:url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABwgAAAABCAYAAADKO/rAAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAABRSURBVFhH7dUxCoBADEXB5LK5/w1iIaLIrsgWNs50Sf/4WVUd8HOZGd1nCqMbGNMPrNMPrJv1cvz0A3OjfuwPvDPrxf7A7t7IlX7gmX74VsQGguw4S6+UnSYAAAAASUVORK5CYII=');">
			<img src="titleleft.png" style="float: left;"/>
			<img src="titleright.png" alt="" style="float: right;" />
		</div>
	</div>
<!-- 制作者 Doxygen 1.8.15 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>首页</span></a></li>
      <li><a href="_xE5_x8F_x91_xE7_x89_x88_xE8_xAF_xB4_xE6_x98_x8E.html"><span>发版说明</span></a></li>
      <li><a href="usergroup0.html"><span>编程引导</span></a></li>
      <li><a href="modules.html"><span>API参考</span></a></li>
      <li><a href="_xE6_x8E_xA7_xE5_x88_xB6_xE5_x8F_xB0_xE7_xA4_xBA_xE4_xBE_x8B_xE7_xA8_x8B_xE5_xBA_x8F.html"><span>示例程序</span></a></li>
      <li><a href="_xE6_xB3_x95_xE5_xBE_x8B_xE5_xA3_xB0_xE6_x98_x8E.html"><span>法律声明</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="PageDoc"><div class="contents">
<div class="textblock"><div class="header" style="margin-left:-12px;margin-top:-10px;margin-right:-8px;"> <div class="headertitle"> <div class="title">采集图像</div> </div> </div> <div id="hikvision"> <br />
 </div><div id="hikvision">工业采集卡SDK支持三种图像采集方式，分别是回调取图（SDK内部分配缓存）、主动取图（SDK内部分配缓存）和主动取图（用户分配并注册缓存），用户可以根据实际应用需求选择合适的采集方式。应当注意的是，这三种图像采集方式同时只能使用一种。此外，工业采集卡SDK也支持获取ChunkData信息、配置取图策略等功能。</div><div id="hikvision"> <ul>
<li>
<a href="#huidiaoqutu" class="el">回调取图（SDK内部分配缓存）</a> </li>
<li>
<a href="#zhudongqutu1" class="el">主动取图（SDK内部分配缓存）</a> </li>
<li>
<a href="#zhudongqutu2" class="el">主动取图（用户分配缓存）</a> </li>
<li>
<a href="#chunkdata" class="el">获取ChunkData信息</a> </li>
<li>
<a href="#peizhiqutucelue" class="el">配置取图策略</a> </li>
</ul>
<br />
 </div><div class="header" style="margin-left:-12px;margin-top:-10px;margin-right:-8px;"> <div class="headertitle"> <div id="huidiaoqutu" class="title">回调取图（SDK内部分配缓存）</div> </div> </div> <div id="hikvision"> <br />
 </div><div id="hikvision">回调取图对用户来说被动采集图像的过程，用户只需将函数指针注册到SDK内部，当有图像生成时，该函数会被自动调用，并将图像数据上传到用户层。该方式编程简单，但取图过程用户不可控。</div><div id="hikvision"> </div><div id="hikvision">基本步骤如下：</div><div id="hikvision"> <ol>
<li>
调用 <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gab17defc955fd688f9446bd0045428870" title="获取流通道数量">MV_FG_GetNumStreams()</a> 接口，获取相机的流通道数量。 </li>
<li>
调用 <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga5baadf4aae39d682049189eeb3dba3c9" title="打开流通道">MV_FG_OpenStream()</a> 接口，输入流通道索引nIndex，打开流通道，并获取流通道句柄。 </li>
<li>
调用 <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gabf595b8cea350b96d8c156a26c0c7ed6" title="设置SDK内部缓存数量">MV_FG_SetBufferNum()</a> 接口配置SDK内部需要申请的图像缓存数量。由于SDK内部默认是没有图像缓存的，所以在选择回调取图方式时，该接口必须被调用。具体申请多少块图像缓存需要根据实际情况决定，主要影响因素有：相机帧率、图像分辨率和电脑配置（主板性能、内存大小）等。 </li>
<li>
调用 <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga115ef26be9f043456d805dc47d99dc18" title="注册帧缓存信息回调函数（SDK内部申请缓存方式）">MV_FG_RegisterFrameCallBackEx()</a> 接口，将图像回调函数注册到SDK内部。其中bBufferRelease参数用于标识图像缓存的两种回收方式：true表示回调函数结束后，SDK提供的图像缓存会被SDK自动回收；false表示回调函数结束后，需要调用 <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga0a80ef9329039ac8d7f47f03e0720cfc" title="释放缓存信息（SDK内部申请缓存方式，此接口用于释放不再使用的图像缓存，与 MV_FG_GetFrameBuffer() 配套使用）">MV_FG_ReleaseFrameBuffer()</a> 接口才能回收SDK提供的图像缓存。 </li>
<li>
调用 <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gac1772dd2bc2a1ddf9fbc28044cd6742a" title="开始取流">MV_FG_StartAcquisition()</a> 接口开始采集图像。 </li>
<li>
当工业采集卡SDK获取到一帧图像，会触发对应的取图回调函数，将该图像数据和图像信息推送给用户。应当注意的是，不建议在取图回调函数中进行耗时操作，这会阻塞后续图像数据和图像信息的推送，建议另开线程进行处理。 </li>
<li>
通过回调方式获取到图像数据后，根据 <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga115ef26be9f043456d805dc47d99dc18" title="注册帧缓存信息回调函数（SDK内部申请缓存方式）">MV_FG_RegisterFrameCallBackEx()</a> 接口输入的bBufferRelease参数不同，有两种处理方式：<br />
 当bBufferRelease为true时，建议深拷贝图像数据到用户自定义的图像缓存；<br />
 当bBufferRelease为false时，可以浅拷贝图像缓存指针到用户自定义缓存列表中，在使用完该图像缓存后，调用 <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga0a80ef9329039ac8d7f47f03e0720cfc" title="释放缓存信息（SDK内部申请缓存方式，此接口用于释放不再使用的图像缓存，与 MV_FG_GetFrameBuffer() 配套使用）">MV_FG_ReleaseFrameBuffer()</a> 接口将其释放回SDK内部。 </li>
<li>
当需要停止采集图像时，可以通过调用 <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga230e6896d6400514748b593b9d3c704b" title="停止取流">MV_FG_StopAcquisition()</a> 接口，输入流通道句柄进行停止。 </li>
<li>
调用 <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga7d5479a027ca49239ca1e9253e986008" title="关闭流通道">MV_FG_CloseStream()</a> 接口关闭流通道。应当注意的是，当流通道被关闭后，原先指向流通道的句柄将失效，不能再用于其它接口的调用。 </li>
</ol>
</div><div id="hikvision"><img src="4.5.1.png" width="710" height="865" alt="" class="inline"/>
</div><div id="hikvision"> <br />
 </div><div id="hikvision">下面的代码片段演示了回调取图的过程，具体示例代码请参考<a class="el" href="_xE5_x9B_x9E_xE8_xB0_x83_xE5_x8F_x96_xE5_x9B_xBE.html">回调取图</a> ：</div><div id="hikvision"> <div class="fragment"><div class="line"><span class="comment">/*获取流通道数量*/</span></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nStreamNum = 0;</div><div class="line">nRet = <a class="code" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gab17defc955fd688f9446bd0045428870">MV_FG_GetNumStreams</a>(hDevice, &amp;nStreamNum);</div><div class="line">Check(nRet);</div><div class="line"></div><div class="line"><span class="comment">/*打开流通道（默认打开0通道）*/</span></div><div class="line"><a class="code" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a> hStream = NULL;</div><div class="line">nRet = <a class="code" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga5baadf4aae39d682049189eeb3dba3c9">MV_FG_OpenStream</a>(hDevice, 0, &amp;hStream); </div><div class="line">Check(nRet);</div><div class="line"></div><div class="line"><span class="comment">/*配置SDK内部缓存数量*/</span></div><div class="line">nRet = <a class="code" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gabf595b8cea350b96d8c156a26c0c7ed6">MV_FG_SetBufferNum</a>(hStream, 3);</div><div class="line">Check(nRet);</div><div class="line"></div><div class="line"><span class="comment">/*注册图像回调函数*/</span></div><div class="line">nRet = <a class="code" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga115ef26be9f043456d805dc47d99dc18">MV_FG_RegisterFrameCallBackEx</a>(hStream, FrameCallBack, hStream, <span class="keyword">false</span>);</div><div class="line">Check(nRet);</div><div class="line"></div><div class="line"><span class="comment">/*开始采集*/</span></div><div class="line">nRet = <a class="code" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gac1772dd2bc2a1ddf9fbc28044cd6742a">MV_FG_StartAcquisition</a>(hStream);</div><div class="line">Check(nRet);</div><div class="line"></div><div class="line"><span class="comment">/*暂停，等待按键输入*/</span></div><div class="line">WaitForKeyPress(); </div><div class="line"></div><div class="line"><span class="comment">/*停止采集*/</span></div><div class="line">nRet = <a class="code" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga230e6896d6400514748b593b9d3c704b">MV_FG_StopAcquisition</a>(hStream);</div><div class="line">Check(nRet);</div><div class="line"></div><div class="line"><span class="comment">/*关闭流通道*/</span></div><div class="line">nRet = <a class="code" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga7d5479a027ca49239ca1e9253e986008">MV_FG_CloseStream</a>(hStream);</div><div class="line">Check(nRet);</div></div><!-- fragment --> </div><div id="hikvision">下面的代码片段演示了取图回调函数推送的内容：</div><div id="hikvision"> <div class="fragment"><div class="line"><span class="comment">/*浅拷贝函数，只是增加了一个指针指向已存在的内存地址，仅仅是指向被复制的内存地址*/</span></div><div class="line"><span class="keywordtype">void</span> ShallowCopyImage(<a class="code" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html">MV_FG_BUFFER_INFO</a>* pstSrcBufInfo, <a class="code" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html">MV_FG_BUFFER_INFO</a>* pstDstBufInfo)</div><div class="line">{</div><div class="line">    memcpy(pstDstBufInfo, pstSrcBufInfo, <span class="keyword">sizeof</span>(<a class="code" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html">MV_FG_BUFFER_INFO</a>));</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/*深拷贝函数，申请了一个新的内存，并将被复制内存地址中的数据复制到新的内存中*/</span></div><div class="line"><span class="keywordtype">void</span> DeepCopyImage(<a class="code" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html">MV_FG_BUFFER_INFO</a>* pstSrcBufInfo, <a class="code" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html">MV_FG_BUFFER_INFO</a>* pstDstBufInfo)</div><div class="line">{</div><div class="line">    memcpy(pstDstBufInfo, pstSrcBufInfo, <span class="keyword">sizeof</span>(<a class="code" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html">MV_FG_BUFFER_INFO</a>));</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* pDstBuf = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*)malloc(pstSrcBufInfo-&gt;<a class="code" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html#ac1821e4c0315f6c0ebbcf907f835f6f6">nFilledSize</a>);</div><div class="line">    memcpy(pDstBuf, pstSrcBufInfo-&gt;<a class="code" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html#ab48e189d395e833f208732a779e526c0">pBuffer</a>, pstSrcBufInfo-&gt;<a class="code" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html#ac1821e4c0315f6c0ebbcf907f835f6f6">nFilledSize</a>);</div><div class="line">    pstDstBufInfo-&gt;<a class="code" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html#ab48e189d395e833f208732a779e526c0">pBuffer</a> = pDstBuf;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/*取图回调函数*/</span></div><div class="line"><span class="keywordtype">void</span> __stdcall FrameCallBack(<a class="code" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html">MV_FG_BUFFER_INFO</a>* pstBufferInfo, <span class="keywordtype">void</span>* pUser)</div><div class="line">{</div><div class="line">    <a class="code" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a> hStream = (<a class="code" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a>)pUser;</div><div class="line">    printf(<span class="stringliteral">&quot;Frame ID: %I64d, Filled Size: %d, Width: %d, Height: %d\r\n&quot;</span>, pstBufferInfo-&gt;<a class="code" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html#a93ebaf10b2b24fa20dc7860964563a22">nFrameID</a>, pstBufferInfo-&gt;<a class="code" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html#ac1821e4c0315f6c0ebbcf907f835f6f6">nFilledSize</a>, pstBufferInfo-&gt;<a class="code" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html#abbc1b35442c6143931edc0189a3432fb">nWidth</a>, pstBufferInfo-&gt;<a class="code" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html#a2e4c6b811457a16b7033af6741cfb1db">nHeight</a>);</div><div class="line">    </div><div class="line">    <span class="comment">/*用户可以浅拷贝图像数据，在回调外部处理图像；也可以深拷贝图像数据到用户分配的缓存中*/</span></div><div class="line">    <a class="code" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html">MV_FG_BUFFER_INFO</a> stDstBufInfo = {0};</div><div class="line">    </div><div class="line">    <span class="comment">/*浅拷贝函数*/</span></div><div class="line">    ShallowCopyImage(pstBufferInfo, &amp;stDstBufInfo);</div><div class="line">    </div><div class="line">    <span class="comment">/*深拷贝函数*/</span></div><div class="line">    <span class="comment">//DeepCopyImage(pstBufferInfo, &amp;stDstBufInfo);</span></div><div class="line"></div><div class="line">    <span class="comment">/*图像处理结束后，再调用以下接口将图像缓存释放回SDK内部*/</span></div><div class="line">    <a class="code" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga0a80ef9329039ac8d7f47f03e0720cfc">MV_FG_ReleaseFrameBuffer</a>(hStream, pstBufferInfo);</div><div class="line">}</div></div><!-- fragment --> <br />
 </div><div class="header" style="margin-left:-12px;margin-top:-10px;margin-right:-8px;"> <div class="headertitle"> <div id="zhudongqutu1" class="title">主动取图（SDK内部分配缓存）</div> </div> </div> <div id="hikvision"> <br />
 </div><div id="hikvision">在SDK内部分配缓存并主动采集图像方式，一般需要用户创建并维护取图线程，用户可以在需要图像时实时采集。对于此种方式，由于图像缓存是SDK内部申请的，通常用户需要将图像数据拷贝到用户申请的缓存中，并进行管理。</div><div id="hikvision"> </div><div id="hikvision">基本步骤如下：</div><div id="hikvision"> <ol>
<li>
调用 <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gab17defc955fd688f9446bd0045428870" title="获取流通道数量">MV_FG_GetNumStreams()</a> 接口，获取相机的流通道数量。 </li>
<li>
调用 <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga5baadf4aae39d682049189eeb3dba3c9" title="打开流通道">MV_FG_OpenStream()</a> 接口，输入流通道索引nIndex，打开流通道，并获取流通道句柄。 </li>
<li>
调用 <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gabf595b8cea350b96d8c156a26c0c7ed6" title="设置SDK内部缓存数量">MV_FG_SetBufferNum()</a> 接口配置SDK内部需要申请的图像缓存数量。由于SDK内部默认是没有图像缓存的，所以在选择SDK内部分配缓存的主动取图方式时，该接口必须被调用。具体申请多少块图像缓存需要根据实际情况决定，主要影响因素有：相机帧率、图像分辨率和电脑配置（主板性能、内存大小）等。 </li>
<li>
创建取图线程。 </li>
<li>
调用 <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gac1772dd2bc2a1ddf9fbc28044cd6742a" title="开始取流">MV_FG_StartAcquisition()</a> 接口开始采集图像。 </li>
<li>
在取图线程中，通过循环调用 <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gab802fc25610648224ff8298c64bceb3d" title="获取一帧图像的缓存信息（SDK内部申请缓存方式）">MV_FG_GetFrameBuffer()</a> 接口获取图像数据和图像信息，并可对获取到的图像进行处理。在图像处理结束后，需要调用 <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga0a80ef9329039ac8d7f47f03e0720cfc" title="释放缓存信息（SDK内部申请缓存方式，此接口用于释放不再使用的图像缓存，与 MV_FG_GetFrameBuffer() 配套使用）">MV_FG_ReleaseFrameBuffer()</a> 接口将图像缓存释放回SDK内部。 </li>
<li>
当需要停止采集图像时，可以通过调用 <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga230e6896d6400514748b593b9d3c704b" title="停止取流">MV_FG_StopAcquisition()</a> 接口，输入流通道句柄进行停止。 </li>
<li>
调用 <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga7d5479a027ca49239ca1e9253e986008" title="关闭流通道">MV_FG_CloseStream()</a> 接口关闭流通道。应当注意的是，当流通道被关闭后，原先指向流通道的句柄将失效，不能再用于其它接口的调用。 </li>
</ol>
</div><div id="hikvision"><img src="4.5.2.png" width="615" height="785" alt="" class="inline"/>
</div><div id="hikvision"> <br />
 </div><div id="hikvision">下面的代码片段演示了主动取图（SDK内部分配缓存）方式的过程，具体示例代码请参考<a class="el" href="_xE4_xB8_xBB_xE5_x8A_xA8_xE5_x8F_x96_xE5_x9B_xBE.html">主动取图</a> ：</div><div id="hikvision"> <div class="fragment"><div class="line"><span class="comment">/*获取流通道数量*/</span></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nStreamNum = 0;</div><div class="line">nRet = <a class="code" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gab17defc955fd688f9446bd0045428870">MV_FG_GetNumStreams</a>(hDevice, &amp;nStreamNum);</div><div class="line">Check(nRet);</div><div class="line"></div><div class="line"><span class="comment">/*打开流通道（默认打开0通道）*/</span></div><div class="line"><a class="code" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a> hStream = NULL;</div><div class="line">nRet = <a class="code" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga5baadf4aae39d682049189eeb3dba3c9">MV_FG_OpenStream</a>(hDevice, 0, &amp;hStream); </div><div class="line">Check(nRet);</div><div class="line"></div><div class="line"><span class="comment">/*配置SDK内部缓存数量*/</span></div><div class="line">nRet = <a class="code" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gabf595b8cea350b96d8c156a26c0c7ed6">MV_FG_SetBufferNum</a>(hStream, 3);</div><div class="line">Check(nRet);</div><div class="line"></div><div class="line"><span class="comment">/*创建取流线程*/</span></div><div class="line">g_bGrab = <span class="keyword">true</span>;</div><div class="line"><span class="keywordtype">void</span>* hThreadHandle = (<span class="keywordtype">void</span>*)_beginthreadex(NULL, 0, GrabbingThread, hStream, 0, NULL);</div><div class="line"><span class="keywordflow">if</span> (NULL == hThreadHandle)</div><div class="line">{</div><div class="line">    printf(<span class="stringliteral">&quot;Create thread failed!\n&quot;</span>);</div><div class="line">    <span class="keywordflow">break</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/*暂停，等待按键输入*/</span></div><div class="line">WaitForKeyPress();</div><div class="line"></div><div class="line"><span class="comment">/*关闭取流线程*/</span></div><div class="line">g_bGrab = <span class="keyword">false</span>;</div><div class="line">WaitForSingleObject(hThreadHandle, INFINITE);</div><div class="line">CloseHandle(hThreadHandle);</div><div class="line">hThreadHandle = NULL;</div><div class="line"></div><div class="line"><span class="comment">/*关闭流通道*/</span></div><div class="line">nRet = <a class="code" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga7d5479a027ca49239ca1e9253e986008">MV_FG_CloseStream</a>(hStream);</div><div class="line">Check(nRet);</div></div><!-- fragment --> </div><div id="hikvision">下面的代码片段演示了取图线程（SDK内部分配缓存）的内容：</div><div id="hikvision"> <div class="fragment"><div class="line"><span class="comment">/*取图线程*/</span></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> __stdcall GrabbingThread(<span class="keywordtype">void</span>* pUser)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (pUser)</div><div class="line">    {</div><div class="line">        <a class="code" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a> hStream = (<a class="code" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a>)pUser;</div><div class="line">        <a class="code" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html">MV_FG_BUFFER_INFO</a> stFrameInfo = { 0 };</div><div class="line"></div><div class="line">        <span class="comment">/*开始采集*/</span></div><div class="line">        nRet = <a class="code" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gac1772dd2bc2a1ddf9fbc28044cd6742a">MV_FG_StartAcquisition</a>(hStream);</div><div class="line">        Check(nRet);</div><div class="line">        <span class="keywordflow">while</span> (g_bGrab)</div><div class="line">        {</div><div class="line">            <span class="comment">/*获取图像缓存*/</span></div><div class="line">            nRet = <a class="code" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gab802fc25610648224ff8298c64bceb3d">MV_FG_GetFrameBuffer</a>(hStream, &amp;stFrameInfo, TIMEOUT);</div><div class="line">            <span class="keywordflow">if</span> (<a class="code" href="group___xE6_xAD_xA3_xE7_xA1_xAE_xE7_xA0_x81.html#ga8f22ace9778d3c38979a9a30425701bf">MV_FG_SUCCESS</a> != nRet)</div><div class="line">            {</div><div class="line">                <span class="keywordflow">continue</span>;</div><div class="line">            }</div><div class="line">            printf(<span class="stringliteral">&quot;Frame ID: %I64d, Filled Size: %d, Width: %d, Height: %d\r\n&quot;</span>, stFrameInfo.<a class="code" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html#a93ebaf10b2b24fa20dc7860964563a22">nFrameID</a>, stFrameInfo.<a class="code" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html#ac1821e4c0315f6c0ebbcf907f835f6f6">nFilledSize</a>, stFrameInfo.<a class="code" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html#abbc1b35442c6143931edc0189a3432fb">nWidth</a>, stFrameInfo.<a class="code" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html#a2e4c6b811457a16b7033af6741cfb1db">nHeight</a>);</div><div class="line">            </div><div class="line">            <span class="comment">/*将图像缓存释放回SDK内部*/</span></div><div class="line">            nRet = <a class="code" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga0a80ef9329039ac8d7f47f03e0720cfc">MV_FG_ReleaseFrameBuffer</a>(hStream, &amp;stFrameInfo);</div><div class="line">            Check(nRet);</div><div class="line">        }</div><div class="line">        <span class="comment">/*停止采集*/</span></div><div class="line">        nRet = <a class="code" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga230e6896d6400514748b593b9d3c704b">MV_FG_StopAcquisition</a>(hStream);</div><div class="line">        Check(nRet);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="group___xE6_xAD_xA3_xE7_xA1_xAE_xE7_xA0_x81.html#ga8f22ace9778d3c38979a9a30425701bf">MV_FG_SUCCESS</a>;</div><div class="line">}</div></div><!-- fragment --> <br />
 </div><div class="header" style="margin-left:-12px;margin-top:-10px;margin-right:-8px;"> <div class="headertitle"> <div id="zhudongqutu2" class="title">主动取图（用户分配缓存）</div> </div> </div> <div id="hikvision"> <br />
 </div><div id="hikvision">通过用户分配并注册缓存方式主动采集图像，既可以在需要图像时实时采集，也可以通过接口调用对图像缓存进行管理。但这种方式有一定的编程难度，需要对接口和调用逻辑有较深的理解。</div><div id="hikvision"> </div><div id="hikvision">基本步骤如下：</div><div id="hikvision"> <ol>
<li>
调用 <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gab17defc955fd688f9446bd0045428870" title="获取流通道数量">MV_FG_GetNumStreams()</a> 接口，获取相机的流通道数量。 </li>
<li>
调用 <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga5baadf4aae39d682049189eeb3dba3c9" title="打开流通道">MV_FG_OpenStream()</a> 接口，输入流通道索引nIndex，打开流通道，并获取流通道句柄。 </li>
<li>
调用 <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga14550b8b6ea4796171669a0bbdd68550" title="获取流通道的图像大小">MV_FG_GetPayloadSize()</a> 接口获取当前流通道的负载数据长度，一般情况下是图像的长度。应当注意的是，修改相机的图像相关参数（如图像宽、图像高和图像像素格式等参数）后需要重新获取流通道的负载数据长度。 </li>
<li>
根据获取到的流通道负载数据长度，申请一定数量的图像缓存。具体申请多少块图像缓存需要根据实际情况决定，主要影响因素有：相机帧率、图像分辨率和电脑配置（主板性能、内存大小）等。 </li>
<li>
调用 <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gaa876df36c0ad4be0e2c7184e5076a0c7" title="向流通道中注册缓存（必须在 MV_FG_StartAcquisition() 前注册缓存）">MV_FG_AnnounceBuffer()</a> 接口将申请的图像缓存依次注册到SDK内部，并获取到每一块图像缓存所对应的缓存句柄，此时注册在SDK内部的图像缓存都被放在待使用的队列中，还不能被SDK使用。 </li>
<li>
将图像缓存注册到SDK内部后，需要调用 <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga11288e3420c666956605afd2cd987c2c" title="刷新缓存队列">MV_FG_FlushQueue()</a> 接口，输入<a class="el" href="group___xE6_x9E_x9A_xE4_xB8_xBE_xE7_xB1_xBB_xE5_x9E_x8B_xE5_xAE_x9A_xE4_xB9_x89.html#ggae5852b0e56ae9feccef5505206d78562a376a5f855e33f3d49b9f17af38ecaacf">MV_FG_BUFFER_QUEUE_ALL_TO_INPUT</a> 类型，将这些图像缓存放入到SDK内部的输入缓存队列中。 </li>
<li>
创建取图线程。 </li>
<li>
通过调用 <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gac1772dd2bc2a1ddf9fbc28044cd6742a" title="开始取流">MV_FG_StartAcquisition()</a> 接口开始采集图像。 </li>
<li>
在取图线程中，通过循环调用 <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga14ab6d598e6b313d373ccc6242c2dfba" title="获取一帧图像的缓存信息（使用 MV_FG_AnnounceBuffer() 注册缓存的取流方式）">MV_FG_GetImageBuffer()</a> 接口获取到图像缓存句柄，然后基于该缓存句柄再调用 <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga6984ec4a8ff98ff1257fa5052de01b06" title="通过缓存句柄获取缓存信息">MV_FG_GetBufferInfo()</a> 接口获取到图像信息和图像数据，并可对获取到的图像进行处理。在图像处理结束后，需要调用 <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga7086bb942615bfeae3078d0342e230de" title="将图像缓存放回输入队列，用于等待采集图像（图像缓存句柄来自 MV_FG_GetImageBuffer() 接口）">MV_FG_QueueBuffer()</a> 接口将图像缓存放回SDK内部的输入队列中，使其能继续用于后续图像的采集。 </li>
<li>
当需要停止采集图像时，可以通过调用 <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga230e6896d6400514748b593b9d3c704b" title="停止取流">MV_FG_StopAcquisition()</a> 接口，输入流通道句柄进行停止。 </li>
<li>
调用 <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga11288e3420c666956605afd2cd987c2c" title="刷新缓存队列">MV_FG_FlushQueue()</a> 接口，输入<a class="el" href="group___xE6_x9E_x9A_xE4_xB8_xBE_xE7_xB1_xBB_xE5_x9E_x8B_xE5_xAE_x9A_xE4_xB9_x89.html#ggae5852b0e56ae9feccef5505206d78562a87a272ac9e6315a6be1e7c9986e71480">MV_FG_BUFFER_QUEUE_ALL_DISCARD</a> 类型，将之前注册到SDK内部的图像缓存都放到待使用队列中。 </li>
<li>
调用 <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga14afae1d79a9402ac008fa463713f3e6" title="从流通道中销毁由 MV_FG_AnnounceBuffer() 接口注册的缓存">MV_FG_RevokeBuffer()</a> 接口，输入缓存句柄，依次将之前注册到SDK内部，并且在待使用队列中的图像缓存进行撤销，撤销后的图像缓存可被用户进行释放。 </li>
<li>
调用 <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga7d5479a027ca49239ca1e9253e986008" title="关闭流通道">MV_FG_CloseStream()</a> 接口关闭流通道。应当注意的是，当流通道被关闭后，原先指向流通道的句柄将失效，不能再用于其它接口的调用。 </li>
</ol>
</div><div id="hikvision"><img src="4.5.3.png" width="660" height="1250" alt="" class="inline"/>
</div><div id="hikvision"> <br />
 </div><div id="hikvision">下面的代码片段演示了主动取图（用户分配缓存）方式的过程，具体示例代码请参考<a class="el" href="_xE7_x94_xA8_xE6_x88_xB7_xE6_xB3_xA8_xE5_x86_x8C_xE7_xBC_x93_xE5_xAD_x98_xE5_x8F_x96_xE5_x9B_xBE.html">用户注册缓存取图</a> 。</div><div id="hikvision"> <div class="fragment"><div class="line"><span class="comment">/*获取流通道数量*/</span></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nStreamNum = 0;</div><div class="line">nRet = <a class="code" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gab17defc955fd688f9446bd0045428870">MV_FG_GetNumStreams</a>(hDevice, &amp;nStreamNum);</div><div class="line">Check(nRet);</div><div class="line"></div><div class="line"><span class="comment">/*打开流通道（默认打开0通道）*/</span></div><div class="line"><a class="code" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a> hStream = NULL;</div><div class="line">nRet = <a class="code" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga5baadf4aae39d682049189eeb3dba3c9">MV_FG_OpenStream</a>(hDevice, 0, &amp;hStream); </div><div class="line">Check(nRet);</div><div class="line"></div><div class="line"><span class="comment">/*获取流通道负载数据长度*/</span></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nPayloadSize = 0;</div><div class="line">nRet = <a class="code" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga14550b8b6ea4796171669a0bbdd68550">MV_FG_GetPayloadSize</a>(hStream, &amp;nPayloadSize);</div><div class="line">Check(nRet);</div><div class="line"></div><div class="line"><span class="comment">/*申请并注册图像缓存*/</span></div><div class="line"><a class="code" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#gaeb7de499673b83a2f7956238b5c03271">BUFFERHANDLE</a> hBuffer[3] = {0};</div><div class="line"><span class="keywordtype">void</span>* pBuffer = NULL;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 3; i++)</div><div class="line">{</div><div class="line">    pBuffer = malloc(nPayloadSize);</div><div class="line">    nRet = <a class="code" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gaa876df36c0ad4be0e2c7184e5076a0c7">MV_FG_AnnounceBuffer</a>(hStream, pBuffer, nPayloadSize, NULL, &amp;(hBuffer[i]));</div><div class="line">    Check(nRet);</div><div class="line">}</div><div class="line">Check(nRet);</div><div class="line"></div><div class="line"><span class="comment">/*将图像缓存放入输入队列*/</span></div><div class="line">nRet = <a class="code" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga11288e3420c666956605afd2cd987c2c">MV_FG_FlushQueue</a>(hStream, <a class="code" href="group___xE6_x9E_x9A_xE4_xB8_xBE_xE7_xB1_xBB_xE5_x9E_x8B_xE5_xAE_x9A_xE4_xB9_x89.html#ggae5852b0e56ae9feccef5505206d78562a376a5f855e33f3d49b9f17af38ecaacf">MV_FG_BUFFER_QUEUE_ALL_TO_INPUT</a>);</div><div class="line">Check(nRet);</div><div class="line"></div><div class="line"><span class="comment">/*创建取流线程*/</span></div><div class="line">g_bGrab = <span class="keyword">true</span>;</div><div class="line"><span class="keywordtype">void</span>* hThreadHandle = (<span class="keywordtype">void</span>*)_beginthreadex(NULL, 0, GrabbingThread, hStream, 0, NULL);</div><div class="line"><span class="keywordflow">if</span> (NULL == hThreadHandle)</div><div class="line">{</div><div class="line">    printf(<span class="stringliteral">&quot;Create thread failed!\n&quot;</span>);</div><div class="line">    <span class="keywordflow">break</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/*暂停，等待按键输入*/</span></div><div class="line">WaitForKeyPress();</div><div class="line"></div><div class="line"><span class="comment">/*关闭取流线程*/</span></div><div class="line">g_bGrab = <span class="keyword">false</span>;</div><div class="line">WaitForSingleObject(hThreadHandle, INFINITE);</div><div class="line">CloseHandle(hThreadHandle);</div><div class="line">hThreadHandle = NULL;</div><div class="line"></div><div class="line"><span class="comment">/*清空缓存队列*/</span></div><div class="line">nRet = <a class="code" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga11288e3420c666956605afd2cd987c2c">MV_FG_FlushQueue</a>(hStream, <a class="code" href="group___xE6_x9E_x9A_xE4_xB8_xBE_xE7_xB1_xBB_xE5_x9E_x8B_xE5_xAE_x9A_xE4_xB9_x89.html#ggae5852b0e56ae9feccef5505206d78562a87a272ac9e6315a6be1e7c9986e71480">MV_FG_BUFFER_QUEUE_ALL_DISCARD</a>);</div><div class="line">Check(nRet);</div><div class="line"></div><div class="line"><span class="comment">/*撤销并释放注册的图像缓存*/</span></div><div class="line"><span class="keywordtype">void</span>* pPrivate = NULL;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 3; i++)</div><div class="line">{</div><div class="line">    nRet = <a class="code" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga14afae1d79a9402ac008fa463713f3e6">MV_FG_RevokeBuffer</a>(hStream, hBuffer[i], &amp;pBuffer, &amp;pPrivate);</div><div class="line">    Check(nRet);</div><div class="line">    hBuffer[i] = NULL;</div><div class="line">    free(pBuffer);      </div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/*关闭流通道*/</span></div><div class="line">nRet = <a class="code" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga7d5479a027ca49239ca1e9253e986008">MV_FG_CloseStream</a>(hStream);</div><div class="line">Check(nRet);</div></div><!-- fragment --> </div><div id="hikvision">下面的代码片段演示了取图线程（用户分配缓存）的内容：</div><div id="hikvision"> <div class="fragment"><div class="line"><span class="comment">/*取图线程*/</span></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> __stdcall GrabbingThread(<span class="keywordtype">void</span>* pUser)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (pUser)</div><div class="line">    {</div><div class="line">        <a class="code" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a> hStream = (<a class="code" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a>)pUser;</div><div class="line">        <a class="code" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#gaeb7de499673b83a2f7956238b5c03271">BUFFERHANDLE</a> hBuffer = NULL;</div><div class="line">        <a class="code" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html">MV_FG_BUFFER_INFO</a> stFrameInfo = { 0 };</div><div class="line"></div><div class="line">        <span class="comment">/*开始采集*/</span></div><div class="line">        nRet = <a class="code" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gac1772dd2bc2a1ddf9fbc28044cd6742a">MV_FG_StartAcquisition</a>(hStream);</div><div class="line">        Check(nRet);</div><div class="line">        <span class="keywordflow">while</span> (g_bGrab)</div><div class="line">        {</div><div class="line">            <span class="comment">/*获取图像缓存*/</span></div><div class="line">            nRet = <a class="code" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga14ab6d598e6b313d373ccc6242c2dfba">MV_FG_GetImageBuffer</a>(hStream, &amp;hBuffer, TIMEOUT);</div><div class="line">            <span class="keywordflow">if</span> (<a class="code" href="group___xE6_xAD_xA3_xE7_xA1_xAE_xE7_xA0_x81.html#ga8f22ace9778d3c38979a9a30425701bf">MV_FG_SUCCESS</a> != nRet)</div><div class="line">            {</div><div class="line">                <span class="keywordflow">continue</span>;</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">/*获取图像信息和数据*/</span></div><div class="line">            nRet = <a class="code" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga6984ec4a8ff98ff1257fa5052de01b06">MV_FG_GetBufferInfo</a>(hBuffer, &amp;stFrameInfo);</div><div class="line">            <span class="keywordflow">if</span> (<a class="code" href="group___xE6_xAD_xA3_xE7_xA1_xAE_xE7_xA0_x81.html#ga8f22ace9778d3c38979a9a30425701bf">MV_FG_SUCCESS</a> == nRet)</div><div class="line">            {</div><div class="line">                printf(<span class="stringliteral">&quot;Frame ID: %I64d, Filled Size: %d, Width: %d, Height: %d\r\n&quot;</span>,</div><div class="line">                stFrameInfo.<a class="code" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html#a93ebaf10b2b24fa20dc7860964563a22">nFrameID</a>, stFrameInfo.<a class="code" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html#ac1821e4c0315f6c0ebbcf907f835f6f6">nFilledSize</a>, stFrameInfo.<a class="code" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html#abbc1b35442c6143931edc0189a3432fb">nWidth</a>,</div><div class="line">                stFrameInfo.<a class="code" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html#a2e4c6b811457a16b7033af6741cfb1db">nHeight</a>);</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">/*将图像缓存放回输入队列*/</span></div><div class="line">            nRet = <a class="code" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga7086bb942615bfeae3078d0342e230de">MV_FG_QueueBuffer</a>(hBuffer);</div><div class="line">            Check(nRet);</div><div class="line">        }</div><div class="line">        <span class="comment">/*停止采集*/</span></div><div class="line">        nRet = <a class="code" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga230e6896d6400514748b593b9d3c704b">MV_FG_StopAcquisition</a>(hStream);</div><div class="line">        Check(nRet);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="group___xE6_xAD_xA3_xE7_xA1_xAE_xE7_xA0_x81.html#ga8f22ace9778d3c38979a9a30425701bf">MV_FG_SUCCESS</a>;</div><div class="line">}</div></div><!-- fragment --> <br />
 </div><div class="header" style="margin-left:-12px;margin-top:-10px;margin-right:-8px;"> <div class="headertitle"> <div id="chunkdata" class="title">获取ChunkData信息</div> </div> </div> <div id="hikvision"> <br />
 </div><div id="hikvision">通过调用 <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga2f77d11bcbc21d52cc5b6173d23a367d" title="获取缓存内的ChunkData信息">MV_FG_GetBufferChunkData()</a> 接口，输入图像缓存，获取图像缓存内的ChunkData信息。该接口需要在获取到图像缓存之后，并且在将图像缓存放回SDK内部之前调用才能得到准确的数据。</div><div id="hikvision"> <div class="fragment"><div class="line"><span class="comment">/*获取图像缓存内的ChunkData信息*/</span></div><div class="line"><a class="code" href="struct_m_v___f_g___c_h_u_n_k___d_a_t_a___i_n_f_o.html">MV_FG_CHUNK_DATA_INFO</a> stChunkDataInfo = {0};</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; stFrameInfo.<a class="code" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html#a578bc8184556174255cd35bcf7d540e7">nNumChunks</a>; i++)</div><div class="line">{</div><div class="line">    memset(&amp;stChunkDataInfo, 0, <span class="keyword">sizeof</span>(<a class="code" href="struct_m_v___f_g___c_h_u_n_k___d_a_t_a___i_n_f_o.html">MV_FG_CHUNK_DATA_INFO</a>));</div><div class="line">    nRet = <a class="code" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga2f77d11bcbc21d52cc5b6173d23a367d">MV_FG_GetBufferChunkData</a>(hStream, &amp;stBufferInfo, i, &amp;stChunkDataInfo);</div><div class="line">    Check(nRet);</div><div class="line">    printf(<span class="stringliteral">&quot;Chunk ID[%#x], Chunk length[%d]\n&quot;</span>, stChunkDataInfo.<a class="code" href="struct_m_v___f_g___c_h_u_n_k___d_a_t_a___i_n_f_o.html#a45254518e0f8137849ce75d381d671ef">nChunkID</a>, </div><div class="line">    stChunkDataInfo.<a class="code" href="struct_m_v___f_g___c_h_u_n_k___d_a_t_a___i_n_f_o.html#a5c2386c95f4c4b59c072f204d236af6e">nChunkLen</a>);</div><div class="line">}</div></div><!-- fragment --> <br />
 </div><div class="header" style="margin-left:-12px;margin-top:-10px;margin-right:-8px;"> <div class="headertitle"> <div id="peizhiqutucelue" class="title">配置取图策略</div> </div> </div> <div id="hikvision"> <br />
 </div><div id="hikvision">通过调用 <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga41f3a68612ff0df995d91306d4e971fe" title="设置取流策略">MV_FG_SetGrabStrategy()</a> 接口设置当前流通道的取流策略，目前定义了4种取流策略，默认为OneByOne策略，可以根据实际应用需求进行选择，具体描述可以参考<a class="el" href="group___xE6_x9E_x9A_xE4_xB8_xBE_xE7_xB1_xBB_xE5_x9E_x8B_xE5_xAE_x9A_xE4_xB9_x89.html#ga32523e01d58a150ced054a22cb911f34">MV_FG_GRAB_STRATEGY</a> 。同时该接口还支持开启垃圾缓存功能，该功能允许在SDK内的可用缓存队列为空时，多申请一块图像缓存进行取图，用于保持SDK内部取图的连贯性，以及方便统计采集卡准确出图数。</div><div id="hikvision"> <div class="fragment"><div class="line"><span class="comment">/*设置取图策略为获取最新的图像缓存，并开启垃圾缓存功能*/</span></div><div class="line">nRet = <a class="code" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga41f3a68612ff0df995d91306d4e971fe">MV_FG_SetGrabStrategy</a>(hStream, <a class="code" href="group___xE6_x9E_x9A_xE4_xB8_xBE_xE7_xB1_xBB_xE5_x9E_x8B_xE5_xAE_x9A_xE4_xB9_x89.html#gga32523e01d58a150ced054a22cb911f34afe1948479db556db22759373784794a2">MV_FG_GrabStrategy_LatestImages</a>, <span class="keyword">true</span>);</div><div class="line">Check(nRet);</div></div><!-- fragment --> <br />
 </div> </div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<div class="footer" style="text-align: right;">
	<hr/>
	<small></small>
</div>
</body>
</html>