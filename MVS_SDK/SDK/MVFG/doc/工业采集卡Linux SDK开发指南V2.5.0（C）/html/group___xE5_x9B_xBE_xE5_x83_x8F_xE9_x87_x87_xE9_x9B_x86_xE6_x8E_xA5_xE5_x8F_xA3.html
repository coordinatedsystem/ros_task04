<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=GB2312"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="custom-style.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
	<div style="overflow: hidden;">
		<div style="height: 57px;min-width: 1039px;background-size: auto 100%;background:url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABwgAAAABCAYAAADKO/rAAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAABRSURBVFhH7dUxCoBADEXB5LK5/w1iIaLIrsgWNs50Sf/4WVUd8HOZGd1nCqMbGNMPrNMPrJv1cvz0A3OjfuwPvDPrxf7A7t7IlX7gmX74VsQGguw4S6+UnSYAAAAASUVORK5CYII=');">
			<img src="titleleft.png" style="float: left;"/>
			<img src="titleright.png" alt="" style="float: right;" />
		</div>
	</div>
<!-- 制作者 Doxygen 1.8.15 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>首页</span></a></li>
      <li><a href="_xE5_x8F_x91_xE7_x89_x88_xE8_xAF_xB4_xE6_x98_x8E.html"><span>发版说明</span></a></li>
      <li><a href="usergroup0.html"><span>编程引导</span></a></li>
      <li class="current"><a href="modules.html"><span>API参考</span></a></li>
      <li><a href="_xE6_x8E_xA7_xE5_x88_xB6_xE5_x8F_xB0_xE7_xA4_xBA_xE4_xBE_x8B_xE7_xA8_x8B_xE5_xBA_x8F.html"><span>示例程序</span></a></li>
      <li><a href="_xE6_xB3_x95_xE5_xBE_x8B_xE5_xA3_xB0_xE6_x98_x8E.html"><span>法律声明</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">函数</a>  </div>
  <div class="headertitle">
<div class="title">图像采集接口</div>  </div>
</div><!--header-->
<div class="contents">

<p>包含流的信息获取、打开和关闭，注册和取消缓存等接口  
<a href="#details">更多...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
函数</h2></td></tr>
<tr class="memitem:gab17defc955fd688f9446bd0045428870"><td class="memItemLeft" align="right" valign="top">MV_FGCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gab17defc955fd688f9446bd0045428870">MV_FG_GetNumStreams</a> (IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga0ecdcce3a277e32beb329eaaa2f7e0a5">DEVHANDLE</a> hDevice, OUT unsigned int *pnNumStreams)</td></tr>
<tr class="memdesc:gab17defc955fd688f9446bd0045428870"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取流通道数量  <a href="#gab17defc955fd688f9446bd0045428870">更多...</a><br /></td></tr>
<tr class="separator:gab17defc955fd688f9446bd0045428870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5baadf4aae39d682049189eeb3dba3c9"><td class="memItemLeft" align="right" valign="top">MV_FGCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga5baadf4aae39d682049189eeb3dba3c9">MV_FG_OpenStream</a> (IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga0ecdcce3a277e32beb329eaaa2f7e0a5">DEVHANDLE</a> hDevice, IN unsigned int nIndex, OUT <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a> *phStream)</td></tr>
<tr class="memdesc:ga5baadf4aae39d682049189eeb3dba3c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">打开流通道  <a href="#ga5baadf4aae39d682049189eeb3dba3c9">更多...</a><br /></td></tr>
<tr class="separator:ga5baadf4aae39d682049189eeb3dba3c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d5479a027ca49239ca1e9253e986008"><td class="memItemLeft" align="right" valign="top">MV_FGCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga7d5479a027ca49239ca1e9253e986008">MV_FG_CloseStream</a> (IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a> hStream)</td></tr>
<tr class="memdesc:ga7d5479a027ca49239ca1e9253e986008"><td class="mdescLeft">&#160;</td><td class="mdescRight">关闭流通道  <a href="#ga7d5479a027ca49239ca1e9253e986008">更多...</a><br /></td></tr>
<tr class="separator:ga7d5479a027ca49239ca1e9253e986008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf595b8cea350b96d8c156a26c0c7ed6"><td class="memItemLeft" align="right" valign="top">MV_FGCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gabf595b8cea350b96d8c156a26c0c7ed6">MV_FG_SetBufferNum</a> (IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a> hStream, IN unsigned int nBufferNum)</td></tr>
<tr class="memdesc:gabf595b8cea350b96d8c156a26c0c7ed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">设置SDK内部缓存数量  <a href="#gabf595b8cea350b96d8c156a26c0c7ed6">更多...</a><br /></td></tr>
<tr class="separator:gabf595b8cea350b96d8c156a26c0c7ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41f3a68612ff0df995d91306d4e971fe"><td class="memItemLeft" align="right" valign="top">MV_FGCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga41f3a68612ff0df995d91306d4e971fe">MV_FG_SetGrabStrategy</a> (IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a> hStream, IN <a class="el" href="group___xE6_x9E_x9A_xE4_xB8_xBE_xE7_xB1_xBB_xE5_x9E_x8B_xE5_xAE_x9A_xE4_xB9_x89.html#ga32523e01d58a150ced054a22cb911f34">MV_FG_GRAB_STRATEGY</a> enGrabStrategy, bool8_t bUseTrashBuffer)</td></tr>
<tr class="memdesc:ga41f3a68612ff0df995d91306d4e971fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">设置取流策略  <a href="#ga41f3a68612ff0df995d91306d4e971fe">更多...</a><br /></td></tr>
<tr class="separator:ga41f3a68612ff0df995d91306d4e971fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe7b5df83580c256b5f6fc53c7875246"><td class="memItemLeft" align="right" valign="top">MV_FGCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gabe7b5df83580c256b5f6fc53c7875246">MV_FG_RegisterFrameCallBack</a> (IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a> hStream, IN <a class="el" href="group___xE4_xBA_x8B_xE4_xBB_xB6_xE6_x8E_xA5_xE5_x8F_xA3.html#gabb6ff9f1c8f7122ed4d7c4efc11f6ca9">MV_FG_FrameCallBack</a> cbFrame, IN void *pUser)</td></tr>
<tr class="memdesc:gabe7b5df83580c256b5f6fc53c7875246"><td class="mdescLeft">&#160;</td><td class="mdescRight">注册帧缓存信息回调函数（SDK内部申请缓存方式）  <a href="#gabe7b5df83580c256b5f6fc53c7875246">更多...</a><br /></td></tr>
<tr class="separator:gabe7b5df83580c256b5f6fc53c7875246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga115ef26be9f043456d805dc47d99dc18"><td class="memItemLeft" align="right" valign="top">MV_FGCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga115ef26be9f043456d805dc47d99dc18">MV_FG_RegisterFrameCallBackEx</a> (IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a> hStream, IN <a class="el" href="group___xE4_xBA_x8B_xE4_xBB_xB6_xE6_x8E_xA5_xE5_x8F_xA3.html#gabb6ff9f1c8f7122ed4d7c4efc11f6ca9">MV_FG_FrameCallBack</a> cbFrame, IN void *pUser, IN bool8_t bBufferRelease)</td></tr>
<tr class="memdesc:ga115ef26be9f043456d805dc47d99dc18"><td class="mdescLeft">&#160;</td><td class="mdescRight">注册帧缓存信息回调函数（SDK内部申请缓存方式）  <a href="#ga115ef26be9f043456d805dc47d99dc18">更多...</a><br /></td></tr>
<tr class="separator:ga115ef26be9f043456d805dc47d99dc18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab802fc25610648224ff8298c64bceb3d"><td class="memItemLeft" align="right" valign="top">MV_FGCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gab802fc25610648224ff8298c64bceb3d">MV_FG_GetFrameBuffer</a> (IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a> hStream, OUT <a class="el" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html">MV_FG_BUFFER_INFO</a> *pstBufferInfo, IN unsigned int nTimeout)</td></tr>
<tr class="memdesc:gab802fc25610648224ff8298c64bceb3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取一帧图像的缓存信息（SDK内部申请缓存方式）  <a href="#gab802fc25610648224ff8298c64bceb3d">更多...</a><br /></td></tr>
<tr class="separator:gab802fc25610648224ff8298c64bceb3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a80ef9329039ac8d7f47f03e0720cfc"><td class="memItemLeft" align="right" valign="top">MV_FGCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga0a80ef9329039ac8d7f47f03e0720cfc">MV_FG_ReleaseFrameBuffer</a> (IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a> hStream, IN <a class="el" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html">MV_FG_BUFFER_INFO</a> *pstBufferInfo)</td></tr>
<tr class="memdesc:ga0a80ef9329039ac8d7f47f03e0720cfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">释放缓存信息（SDK内部申请缓存方式，此接口用于释放不再使用的图像缓存，与 <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gab802fc25610648224ff8298c64bceb3d" title="获取一帧图像的缓存信息（SDK内部申请缓存方式）">MV_FG_GetFrameBuffer()</a> 配套使用）  <a href="#ga0a80ef9329039ac8d7f47f03e0720cfc">更多...</a><br /></td></tr>
<tr class="separator:ga0a80ef9329039ac8d7f47f03e0720cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f77d11bcbc21d52cc5b6173d23a367d"><td class="memItemLeft" align="right" valign="top">MV_FGCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga2f77d11bcbc21d52cc5b6173d23a367d">MV_FG_GetBufferChunkData</a> (IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a> hStream, IN <a class="el" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html">MV_FG_BUFFER_INFO</a> *pstBufferInfo, IN unsigned int nIndex, OUT <a class="el" href="struct_m_v___f_g___c_h_u_n_k___d_a_t_a___i_n_f_o.html">MV_FG_CHUNK_DATA_INFO</a> *pstChunkDataInfo)</td></tr>
<tr class="memdesc:ga2f77d11bcbc21d52cc5b6173d23a367d"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取缓存内的ChunkData信息  <a href="#ga2f77d11bcbc21d52cc5b6173d23a367d">更多...</a><br /></td></tr>
<tr class="separator:ga2f77d11bcbc21d52cc5b6173d23a367d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14550b8b6ea4796171669a0bbdd68550"><td class="memItemLeft" align="right" valign="top">MV_FGCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga14550b8b6ea4796171669a0bbdd68550">MV_FG_GetPayloadSize</a> (IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a> hStream, OUT unsigned int *pnPayloadSize)</td></tr>
<tr class="memdesc:ga14550b8b6ea4796171669a0bbdd68550"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取流通道的图像大小  <a href="#ga14550b8b6ea4796171669a0bbdd68550">更多...</a><br /></td></tr>
<tr class="separator:ga14550b8b6ea4796171669a0bbdd68550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa876df36c0ad4be0e2c7184e5076a0c7"><td class="memItemLeft" align="right" valign="top">MV_FGCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gaa876df36c0ad4be0e2c7184e5076a0c7">MV_FG_AnnounceBuffer</a> (IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a> hStream, IN void *pBuffer, IN unsigned int nSize, IN void *pPrivate, OUT <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#gaeb7de499673b83a2f7956238b5c03271">BUFFERHANDLE</a> *phBuffer)</td></tr>
<tr class="memdesc:gaa876df36c0ad4be0e2c7184e5076a0c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">向流通道中注册缓存（必须在 <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gac1772dd2bc2a1ddf9fbc28044cd6742a" title="开始取流">MV_FG_StartAcquisition()</a> 前注册缓存）  <a href="#gaa876df36c0ad4be0e2c7184e5076a0c7">更多...</a><br /></td></tr>
<tr class="separator:gaa876df36c0ad4be0e2c7184e5076a0c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14afae1d79a9402ac008fa463713f3e6"><td class="memItemLeft" align="right" valign="top">MV_FGCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga14afae1d79a9402ac008fa463713f3e6">MV_FG_RevokeBuffer</a> (IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a> hStream, IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#gaeb7de499673b83a2f7956238b5c03271">BUFFERHANDLE</a> hBuffer, OUT void **pBuffer, OUT void **pPrivate)</td></tr>
<tr class="memdesc:ga14afae1d79a9402ac008fa463713f3e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">从流通道中销毁由 <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gaa876df36c0ad4be0e2c7184e5076a0c7" title="向流通道中注册缓存（必须在 MV_FG_StartAcquisition() 前注册缓存）">MV_FG_AnnounceBuffer()</a> 接口注册的缓存  <a href="#ga14afae1d79a9402ac008fa463713f3e6">更多...</a><br /></td></tr>
<tr class="separator:ga14afae1d79a9402ac008fa463713f3e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11288e3420c666956605afd2cd987c2c"><td class="memItemLeft" align="right" valign="top">MV_FGCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga11288e3420c666956605afd2cd987c2c">MV_FG_FlushQueue</a> (IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a> hStream, IN <a class="el" href="group___xE6_x9E_x9A_xE4_xB8_xBE_xE7_xB1_xBB_xE5_x9E_x8B_xE5_xAE_x9A_xE4_xB9_x89.html#gae5852b0e56ae9feccef5505206d78562">MV_FG_BUFFER_QUEUE_TYPE</a> enQueueType)</td></tr>
<tr class="memdesc:ga11288e3420c666956605afd2cd987c2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">刷新缓存队列  <a href="#ga11288e3420c666956605afd2cd987c2c">更多...</a><br /></td></tr>
<tr class="separator:ga11288e3420c666956605afd2cd987c2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1772dd2bc2a1ddf9fbc28044cd6742a"><td class="memItemLeft" align="right" valign="top">MV_FGCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gac1772dd2bc2a1ddf9fbc28044cd6742a">MV_FG_StartAcquisition</a> (IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a> hStream)</td></tr>
<tr class="memdesc:gac1772dd2bc2a1ddf9fbc28044cd6742a"><td class="mdescLeft">&#160;</td><td class="mdescRight">开始取流  <a href="#gac1772dd2bc2a1ddf9fbc28044cd6742a">更多...</a><br /></td></tr>
<tr class="separator:gac1772dd2bc2a1ddf9fbc28044cd6742a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga230e6896d6400514748b593b9d3c704b"><td class="memItemLeft" align="right" valign="top">MV_FGCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga230e6896d6400514748b593b9d3c704b">MV_FG_StopAcquisition</a> (IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a> hStream)</td></tr>
<tr class="memdesc:ga230e6896d6400514748b593b9d3c704b"><td class="mdescLeft">&#160;</td><td class="mdescRight">停止取流  <a href="#ga230e6896d6400514748b593b9d3c704b">更多...</a><br /></td></tr>
<tr class="separator:ga230e6896d6400514748b593b9d3c704b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14ab6d598e6b313d373ccc6242c2dfba"><td class="memItemLeft" align="right" valign="top">MV_FGCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga14ab6d598e6b313d373ccc6242c2dfba">MV_FG_GetImageBuffer</a> (IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a> hStream, OUT <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#gaeb7de499673b83a2f7956238b5c03271">BUFFERHANDLE</a> *phBuffer, IN unsigned int nTimeout)</td></tr>
<tr class="memdesc:ga14ab6d598e6b313d373ccc6242c2dfba"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取一帧图像的缓存信息（使用 <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gaa876df36c0ad4be0e2c7184e5076a0c7" title="向流通道中注册缓存（必须在 MV_FG_StartAcquisition() 前注册缓存）">MV_FG_AnnounceBuffer()</a> 注册缓存的取流方式）  <a href="#ga14ab6d598e6b313d373ccc6242c2dfba">更多...</a><br /></td></tr>
<tr class="separator:ga14ab6d598e6b313d373ccc6242c2dfba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6984ec4a8ff98ff1257fa5052de01b06"><td class="memItemLeft" align="right" valign="top">MV_FGCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga6984ec4a8ff98ff1257fa5052de01b06">MV_FG_GetBufferInfo</a> (IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#gaeb7de499673b83a2f7956238b5c03271">BUFFERHANDLE</a> hBuffer, OUT <a class="el" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html">MV_FG_BUFFER_INFO</a> *pstBufferInfo)</td></tr>
<tr class="memdesc:ga6984ec4a8ff98ff1257fa5052de01b06"><td class="mdescLeft">&#160;</td><td class="mdescRight">通过缓存句柄获取缓存信息  <a href="#ga6984ec4a8ff98ff1257fa5052de01b06">更多...</a><br /></td></tr>
<tr class="separator:ga6984ec4a8ff98ff1257fa5052de01b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7086bb942615bfeae3078d0342e230de"><td class="memItemLeft" align="right" valign="top">MV_FGCTRL_API int __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga7086bb942615bfeae3078d0342e230de">MV_FG_QueueBuffer</a> (IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#gaeb7de499673b83a2f7956238b5c03271">BUFFERHANDLE</a> hBuffer)</td></tr>
<tr class="memdesc:ga7086bb942615bfeae3078d0342e230de"><td class="mdescLeft">&#160;</td><td class="mdescRight">将图像缓存放回输入队列，用于等待采集图像（图像缓存句柄来自 <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga14ab6d598e6b313d373ccc6242c2dfba" title="获取一帧图像的缓存信息（使用 MV_FG_AnnounceBuffer() 注册缓存的取流方式）">MV_FG_GetImageBuffer()</a> 接口）  <a href="#ga7086bb942615bfeae3078d0342e230de">更多...</a><br /></td></tr>
<tr class="separator:ga7086bb942615bfeae3078d0342e230de"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">详细描述</h2>
<p>包含流的信息获取、打开和关闭，注册和取消缓存等接口 </p>
<h2 class="groupheader">函数说明</h2>
<a id="gab17defc955fd688f9446bd0045428870"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab17defc955fd688f9446bd0045428870">&#9670;&nbsp;</a></span>MV_FG_GetNumStreams()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_FGCTRL_API int __stdcall MV_FG_GetNumStreams </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga0ecdcce3a277e32beb329eaaa2f7e0a5">DEVHANDLE</a>&#160;</td>
          <td class="paramname"><em>hDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT unsigned int *&#160;</td>
          <td class="paramname"><em>pnNumStreams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>获取流通道数量 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDevice</td><td>[IN] 相机句柄 </td></tr>
    <tr><td class="paramname">pnNumStreams</td><td>[OUT] 流通道数量 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>成功，返回<a class="el" href="group___xE7_x8A_xB6_xE6_x80_x81_xE7_xA0_x81.html">MV_FG_SUCCESS</a>；失败，返回<a class="el" href="group___xE7_x8A_xB6_xE6_x80_x81_xE7_xA0_x81.html">状态码</a> </dd></dl>
<dl class="section remark"><dt>备注</dt><dd>目前一个相机只支持一个流通道。 </dd></dl>

</div>
</div>
<a id="ga5baadf4aae39d682049189eeb3dba3c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5baadf4aae39d682049189eeb3dba3c9">&#9670;&nbsp;</a></span>MV_FG_OpenStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_FGCTRL_API int __stdcall MV_FG_OpenStream </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga0ecdcce3a277e32beb329eaaa2f7e0a5">DEVHANDLE</a>&#160;</td>
          <td class="paramname"><em>hDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN unsigned int&#160;</td>
          <td class="paramname"><em>nIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a> *&#160;</td>
          <td class="paramname"><em>phStream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>打开流通道 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDevice</td><td>[IN] 相机句柄 </td></tr>
    <tr><td class="paramname">nIndex</td><td>[IN] 流通道索引 </td></tr>
    <tr><td class="paramname">phStream</td><td>[OUT] 流通道句柄 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>成功，返回<a class="el" href="group___xE7_x8A_xB6_xE6_x80_x81_xE7_xA0_x81.html">MV_FG_SUCCESS</a>；失败，返回<a class="el" href="group___xE7_x8A_xB6_xE6_x80_x81_xE7_xA0_x81.html">状态码</a> </dd></dl>

</div>
</div>
<a id="ga7d5479a027ca49239ca1e9253e986008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d5479a027ca49239ca1e9253e986008">&#9670;&nbsp;</a></span>MV_FG_CloseStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_FGCTRL_API int __stdcall MV_FG_CloseStream </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a>&#160;</td>
          <td class="paramname"><em>hStream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>关闭流通道 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">hStream</td><td>[IN] 流通道句柄 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>成功，返回<a class="el" href="group___xE7_x8A_xB6_xE6_x80_x81_xE7_xA0_x81.html">MV_FG_SUCCESS</a>；失败，返回<a class="el" href="group___xE7_x8A_xB6_xE6_x80_x81_xE7_xA0_x81.html">状态码</a> </dd></dl>

</div>
</div>
<a id="gabf595b8cea350b96d8c156a26c0c7ed6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf595b8cea350b96d8c156a26c0c7ed6">&#9670;&nbsp;</a></span>MV_FG_SetBufferNum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_FGCTRL_API int __stdcall MV_FG_SetBufferNum </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a>&#160;</td>
          <td class="paramname"><em>hStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN unsigned int&#160;</td>
          <td class="paramname"><em>nBufferNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>设置SDK内部缓存数量 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">hStream</td><td>[IN] 流通道句柄 </td></tr>
    <tr><td class="paramname">nBufferNum</td><td>[IN] 缓存数量 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>成功，返回<a class="el" href="group___xE7_x8A_xB6_xE6_x80_x81_xE7_xA0_x81.html">MV_FG_SUCCESS</a>；失败，返回<a class="el" href="group___xE7_x8A_xB6_xE6_x80_x81_xE7_xA0_x81.html">状态码</a> </dd></dl>
<dl class="section remark"><dt>备注</dt><dd>当未调用该接口或者nBufferNum参数设置为0时，表示SDK内部无缓存，此时需要用户申请缓存并向流通道注册缓存，否则无法开始取流。<br />
 当nBufferNum参数设置大于0时，表示缓存由SDK内部进行申请，此时不允许用户向流通道注册缓存。<br />
 需合理分配图像缓存数量。在Linux操作系统中，当分配的图像缓存数量过大，导致系统内存过低，应用程序会被操作系统杀死。 </dd></dl>

</div>
</div>
<a id="ga41f3a68612ff0df995d91306d4e971fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41f3a68612ff0df995d91306d4e971fe">&#9670;&nbsp;</a></span>MV_FG_SetGrabStrategy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_FGCTRL_API int __stdcall MV_FG_SetGrabStrategy </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a>&#160;</td>
          <td class="paramname"><em>hStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN <a class="el" href="group___xE6_x9E_x9A_xE4_xB8_xBE_xE7_xB1_xBB_xE5_x9E_x8B_xE5_xAE_x9A_xE4_xB9_x89.html#ga32523e01d58a150ced054a22cb911f34">MV_FG_GRAB_STRATEGY</a>&#160;</td>
          <td class="paramname"><em>enGrabStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool8_t&#160;</td>
          <td class="paramname"><em>bUseTrashBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>设置取流策略 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">hStream</td><td>[IN] 流通道句柄 </td></tr>
    <tr><td class="paramname">enGrabStrategy</td><td>[IN] 取流策略 </td></tr>
    <tr><td class="paramname">bUseTrashBuffer</td><td>[IN] 是否使用垃圾缓存，0表示关闭，1表示开启 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>成功，返回<a class="el" href="group___xE7_x8A_xB6_xE6_x80_x81_xE7_xA0_x81.html">MV_FG_SUCCESS</a>；失败，返回<a class="el" href="group___xE7_x8A_xB6_xE6_x80_x81_xE7_xA0_x81.html">状态码</a> </dd></dl>
<dl class="section remark"><dt>备注</dt><dd>该接口定义了4种取流策略，可以根据实际需求进行选择。具体描述如下：<br />
<ul>
<li>OneByOne：从旧到新一帧一帧的从输出缓存列表中获取图像，创建流通道后默认为该策略<br />
</li>
<li>LatestImagesOnly：仅从输出缓存列表中获取最新的一帧图像，同时清空输出缓存列表<br />
</li>
<li>LatestImages：从输出缓存列表中获取最新的图像，不清空输出缓存列表<br />
</li>
<li>UpcomingImage：在调用取图接口时清空输出缓存列表中所有图像，并等待相机即将生成的一帧图像。<br />
 当bUseTrashBuffer=true时, 如果注册的缓存全部被取走且没有调用 <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga0a80ef9329039ac8d7f47f03e0720cfc" title="释放缓存信息（SDK内部申请缓存方式，此接口用于释放不再使用的图像缓存，与 MV_FG_GetFrameBuffer() 配套使用）">MV_FG_ReleaseFrameBuffer()</a> 、 <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga7086bb942615bfeae3078d0342e230de" title="将图像缓存放回输入队列，用于等待采集图像（图像缓存句柄来自 MV_FG_GetImageBuffer() 接口）">MV_FG_QueueBuffer()</a> 、 <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga11288e3420c666956605afd2cd987c2c" title="刷新缓存队列">MV_FG_FlushQueue()</a> 将缓存放回，开始使用内部垃圾缓存接收图像，接收到的图像会被丢弃，防止采集卡端丢图。 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gabe7b5df83580c256b5f6fc53c7875246"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe7b5df83580c256b5f6fc53c7875246">&#9670;&nbsp;</a></span>MV_FG_RegisterFrameCallBack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_FGCTRL_API int __stdcall MV_FG_RegisterFrameCallBack </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a>&#160;</td>
          <td class="paramname"><em>hStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN <a class="el" href="group___xE4_xBA_x8B_xE4_xBB_xB6_xE6_x8E_xA5_xE5_x8F_xA3.html#gabb6ff9f1c8f7122ed4d7c4efc11f6ca9">MV_FG_FrameCallBack</a>&#160;</td>
          <td class="paramname"><em>cbFrame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN void *&#160;</td>
          <td class="paramname"><em>pUser</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>注册帧缓存信息回调函数（SDK内部申请缓存方式） </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">hStream</td><td>[IN] 流通道句柄 </td></tr>
    <tr><td class="paramname">cbFrame</td><td>[IN] 帧缓存信息回调函数 </td></tr>
    <tr><td class="paramname">pUser</td><td>[IN] 用户自定义数据 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>成功，返回<a class="el" href="group___xE7_x8A_xB6_xE6_x80_x81_xE7_xA0_x81.html">MV_FG_SUCCESS</a>；失败，返回<a class="el" href="group___xE7_x8A_xB6_xE6_x80_x81_xE7_xA0_x81.html">状态码</a> </dd></dl>
<dl class="section remark"><dt>备注</dt><dd>在回调函数中处理耗时操作会阻塞后续帧信息获取。<br />
 注册回调方式和MV_FG_GetFrameBuffer互斥。<br />
 必须在调用 <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gac1772dd2bc2a1ddf9fbc28044cd6742a" title="开始取流">MV_FG_StartAcquisition()</a> 前注册回调函数。 </dd></dl>

</div>
</div>
<a id="ga115ef26be9f043456d805dc47d99dc18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga115ef26be9f043456d805dc47d99dc18">&#9670;&nbsp;</a></span>MV_FG_RegisterFrameCallBackEx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_FGCTRL_API int __stdcall MV_FG_RegisterFrameCallBackEx </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a>&#160;</td>
          <td class="paramname"><em>hStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN <a class="el" href="group___xE4_xBA_x8B_xE4_xBB_xB6_xE6_x8E_xA5_xE5_x8F_xA3.html#gabb6ff9f1c8f7122ed4d7c4efc11f6ca9">MV_FG_FrameCallBack</a>&#160;</td>
          <td class="paramname"><em>cbFrame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN void *&#160;</td>
          <td class="paramname"><em>pUser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN bool8_t&#160;</td>
          <td class="paramname"><em>bBufferRelease</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>注册帧缓存信息回调函数（SDK内部申请缓存方式） </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">hStream</td><td>[IN] 流通道句柄 </td></tr>
    <tr><td class="paramname">cbFrame</td><td>[IN] 帧缓存信息回调函数 </td></tr>
    <tr><td class="paramname">pUser</td><td>[IN] 用户自定义数据 </td></tr>
    <tr><td class="paramname">bBufferRelease</td><td>[IN] 缓存回收标记（1：回调函数结束后内存自动被回收；0：回调函数结束后，需要调用 <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga0a80ef9329039ac8d7f47f03e0720cfc" title="释放缓存信息（SDK内部申请缓存方式，此接口用于释放不再使用的图像缓存，与 MV_FG_GetFrameBuffer() 配套使用）">MV_FG_ReleaseFrameBuffer()</a> 才能回收） </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>成功，返回<a class="el" href="group___xE7_x8A_xB6_xE6_x80_x81_xE7_xA0_x81.html">MV_FG_SUCCESS</a>；失败，返回<a class="el" href="group___xE7_x8A_xB6_xE6_x80_x81_xE7_xA0_x81.html">状态码</a> </dd></dl>
<dl class="section remark"><dt>备注</dt><dd>在回调函数中处理耗时操作会阻塞后续帧信息获取。<br />
 注册回调方式和 <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gab802fc25610648224ff8298c64bceb3d" title="获取一帧图像的缓存信息（SDK内部申请缓存方式）">MV_FG_GetFrameBuffer()</a> 互斥。<br />
 必须在调用 <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gac1772dd2bc2a1ddf9fbc28044cd6742a" title="开始取流">MV_FG_StartAcquisition()</a> 前注册回调函数。 </dd></dl>

</div>
</div>
<a id="gab802fc25610648224ff8298c64bceb3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab802fc25610648224ff8298c64bceb3d">&#9670;&nbsp;</a></span>MV_FG_GetFrameBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_FGCTRL_API int __stdcall MV_FG_GetFrameBuffer </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a>&#160;</td>
          <td class="paramname"><em>hStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT <a class="el" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html">MV_FG_BUFFER_INFO</a> *&#160;</td>
          <td class="paramname"><em>pstBufferInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN unsigned int&#160;</td>
          <td class="paramname"><em>nTimeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>获取一帧图像的缓存信息（SDK内部申请缓存方式） </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">hStream</td><td>[IN] 流通道句柄 </td></tr>
    <tr><td class="paramname">pstBufferInfo</td><td>[OUT] 缓存信息 </td></tr>
    <tr><td class="paramname">nTimeout</td><td>[IN] 超时时间，以毫秒为单位 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>成功，返回<a class="el" href="group___xE7_x8A_xB6_xE6_x80_x81_xE7_xA0_x81.html">MV_FG_SUCCESS</a>；失败，返回<a class="el" href="group___xE7_x8A_xB6_xE6_x80_x81_xE7_xA0_x81.html">状态码</a> </dd></dl>
<dl class="section remark"><dt>备注</dt><dd>需要调用 <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga0a80ef9329039ac8d7f47f03e0720cfc" title="释放缓存信息（SDK内部申请缓存方式，此接口用于释放不再使用的图像缓存，与 MV_FG_GetFrameBuffer() 配套使用）">MV_FG_ReleaseFrameBuffer()</a> 接口进行缓存信息的释放。 </dd></dl>

</div>
</div>
<a id="ga0a80ef9329039ac8d7f47f03e0720cfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a80ef9329039ac8d7f47f03e0720cfc">&#9670;&nbsp;</a></span>MV_FG_ReleaseFrameBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_FGCTRL_API int __stdcall MV_FG_ReleaseFrameBuffer </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a>&#160;</td>
          <td class="paramname"><em>hStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN <a class="el" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html">MV_FG_BUFFER_INFO</a> *&#160;</td>
          <td class="paramname"><em>pstBufferInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>释放缓存信息（SDK内部申请缓存方式，此接口用于释放不再使用的图像缓存，与 <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gab802fc25610648224ff8298c64bceb3d" title="获取一帧图像的缓存信息（SDK内部申请缓存方式）">MV_FG_GetFrameBuffer()</a> 配套使用） </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">hStream</td><td>[IN] 流通道句柄 </td></tr>
    <tr><td class="paramname">pstBufferInfo</td><td>[IN] 缓存信息 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>成功，返回<a class="el" href="group___xE7_x8A_xB6_xE6_x80_x81_xE7_xA0_x81.html">MV_FG_SUCCESS</a>；失败，返回<a class="el" href="group___xE7_x8A_xB6_xE6_x80_x81_xE7_xA0_x81.html">状态码</a> </dd></dl>
<dl class="section remark"><dt>备注</dt><dd>该接口用于释放不再使用的图像缓存，与 <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gab802fc25610648224ff8298c64bceb3d" title="获取一帧图像的缓存信息（SDK内部申请缓存方式）">MV_FG_GetFrameBuffer()</a> 配套使用。使用 <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gab802fc25610648224ff8298c64bceb3d" title="获取一帧图像的缓存信息（SDK内部申请缓存方式）">MV_FG_GetFrameBuffer()</a> 接口取到的图像数据pstBufferInfo，需要用 <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga0a80ef9329039ac8d7f47f03e0720cfc" title="释放缓存信息（SDK内部申请缓存方式，此接口用于释放不再使用的图像缓存，与 MV_FG_GetFrameBuffer() 配套使用）">MV_FG_ReleaseFrameBuffer()</a> 接口进行权限释放。 </dd></dl>

</div>
</div>
<a id="ga2f77d11bcbc21d52cc5b6173d23a367d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f77d11bcbc21d52cc5b6173d23a367d">&#9670;&nbsp;</a></span>MV_FG_GetBufferChunkData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_FGCTRL_API int __stdcall MV_FG_GetBufferChunkData </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a>&#160;</td>
          <td class="paramname"><em>hStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN <a class="el" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html">MV_FG_BUFFER_INFO</a> *&#160;</td>
          <td class="paramname"><em>pstBufferInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN unsigned int&#160;</td>
          <td class="paramname"><em>nIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT <a class="el" href="struct_m_v___f_g___c_h_u_n_k___d_a_t_a___i_n_f_o.html">MV_FG_CHUNK_DATA_INFO</a> *&#160;</td>
          <td class="paramname"><em>pstChunkDataInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>获取缓存内的ChunkData信息 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">hStream</td><td>[IN] 流通道句柄 </td></tr>
    <tr><td class="paramname">pstBufferInfo</td><td>[IN] 缓存信息 </td></tr>
    <tr><td class="paramname">nIndex</td><td>[IN] ChunkData索引 </td></tr>
    <tr><td class="paramname">pstChunkDataInfo</td><td>[OUT] ChunkData信息 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>成功，返回<a class="el" href="group___xE7_x8A_xB6_xE6_x80_x81_xE7_xA0_x81.html">MV_FG_SUCCESS</a>；失败，返回<a class="el" href="group___xE7_x8A_xB6_xE6_x80_x81_xE7_xA0_x81.html">状态码</a> </dd></dl>
<dl class="section remark"><dt>备注</dt><dd>在获取到缓存信息之后，调用 <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga0a80ef9329039ac8d7f47f03e0720cfc" title="释放缓存信息（SDK内部申请缓存方式，此接口用于释放不再使用的图像缓存，与 MV_FG_GetFrameBuffer() 配套使用）">MV_FG_ReleaseFrameBuffer()</a> 或者 <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga7086bb942615bfeae3078d0342e230de" title="将图像缓存放回输入队列，用于等待采集图像（图像缓存句柄来自 MV_FG_GetImageBuffer() 接口）">MV_FG_QueueBuffer()</a> 之前调用该接口才能得到有效信息。 </dd></dl>

</div>
</div>
<a id="ga14550b8b6ea4796171669a0bbdd68550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14550b8b6ea4796171669a0bbdd68550">&#9670;&nbsp;</a></span>MV_FG_GetPayloadSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_FGCTRL_API int __stdcall MV_FG_GetPayloadSize </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a>&#160;</td>
          <td class="paramname"><em>hStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT unsigned int *&#160;</td>
          <td class="paramname"><em>pnPayloadSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>获取流通道的图像大小 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">hStream</td><td>[IN] 流通道句柄 </td></tr>
    <tr><td class="paramname">pnPayloadSize</td><td>[OUT] 流通道的图像大小 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>成功，返回<a class="el" href="group___xE7_x8A_xB6_xE6_x80_x81_xE7_xA0_x81.html">MV_FG_SUCCESS</a>；失败，返回<a class="el" href="group___xE7_x8A_xB6_xE6_x80_x81_xE7_xA0_x81.html">状态码</a> </dd></dl>
<dl class="section remark"><dt>备注</dt><dd>修改相机图像相关参数如宽高、像素格式等参数后需要重新获取流通道的图像大小。 </dd></dl>

</div>
</div>
<a id="gaa876df36c0ad4be0e2c7184e5076a0c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa876df36c0ad4be0e2c7184e5076a0c7">&#9670;&nbsp;</a></span>MV_FG_AnnounceBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_FGCTRL_API int __stdcall MV_FG_AnnounceBuffer </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a>&#160;</td>
          <td class="paramname"><em>hStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN void *&#160;</td>
          <td class="paramname"><em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN unsigned int&#160;</td>
          <td class="paramname"><em>nSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN void *&#160;</td>
          <td class="paramname"><em>pPrivate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#gaeb7de499673b83a2f7956238b5c03271">BUFFERHANDLE</a> *&#160;</td>
          <td class="paramname"><em>phBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>向流通道中注册缓存（必须在 <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gac1772dd2bc2a1ddf9fbc28044cd6742a" title="开始取流">MV_FG_StartAcquisition()</a> 前注册缓存） </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">hStream</td><td>[IN] 流通道句柄 </td></tr>
    <tr><td class="paramname">pBuffer</td><td>[IN] 图像缓存地址 </td></tr>
    <tr><td class="paramname">nSize</td><td>[IN] 图像缓存大小 </td></tr>
    <tr><td class="paramname">pPrivate</td><td>[IN] 私有信息地址 </td></tr>
    <tr><td class="paramname">phBuffer</td><td>[OUT] 缓存句柄 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>成功，返回<a class="el" href="group___xE7_x8A_xB6_xE6_x80_x81_xE7_xA0_x81.html">MV_FG_SUCCESS</a>；失败，返回<a class="el" href="group___xE7_x8A_xB6_xE6_x80_x81_xE7_xA0_x81.html">状态码</a> </dd></dl>
<dl class="section remark"><dt>备注</dt><dd>图像缓存大小通过 <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga14550b8b6ea4796171669a0bbdd68550" title="获取流通道的图像大小">MV_FG_GetPayloadSize()</a> 接口获取；私有信息由用户自定义。 </dd></dl>

</div>
</div>
<a id="ga14afae1d79a9402ac008fa463713f3e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14afae1d79a9402ac008fa463713f3e6">&#9670;&nbsp;</a></span>MV_FG_RevokeBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_FGCTRL_API int __stdcall MV_FG_RevokeBuffer </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a>&#160;</td>
          <td class="paramname"><em>hStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#gaeb7de499673b83a2f7956238b5c03271">BUFFERHANDLE</a>&#160;</td>
          <td class="paramname"><em>hBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT void **&#160;</td>
          <td class="paramname"><em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT void **&#160;</td>
          <td class="paramname"><em>pPrivate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>从流通道中销毁由 <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gaa876df36c0ad4be0e2c7184e5076a0c7" title="向流通道中注册缓存（必须在 MV_FG_StartAcquisition() 前注册缓存）">MV_FG_AnnounceBuffer()</a> 接口注册的缓存 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">hStream</td><td>[IN] 流通道句柄 </td></tr>
    <tr><td class="paramname">hBuffer</td><td>[IN] 缓存句柄 </td></tr>
    <tr><td class="paramname">pBuffer</td><td>[OUT] 图像缓存地址 </td></tr>
    <tr><td class="paramname">pPrivate</td><td>[OUT] 私有信息地址 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>成功，返回<a class="el" href="group___xE7_x8A_xB6_xE6_x80_x81_xE7_xA0_x81.html">MV_FG_SUCCESS</a>；失败，返回<a class="el" href="group___xE7_x8A_xB6_xE6_x80_x81_xE7_xA0_x81.html">状态码</a> </dd></dl>
<dl class="section remark"><dt>备注</dt><dd>只能撤销未使用队列中的缓存，可通过 <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga11288e3420c666956605afd2cd987c2c" title="刷新缓存队列">MV_FG_FlushQueue()</a> 接口将缓存放到未使用队列。 </dd></dl>

</div>
</div>
<a id="ga11288e3420c666956605afd2cd987c2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11288e3420c666956605afd2cd987c2c">&#9670;&nbsp;</a></span>MV_FG_FlushQueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_FGCTRL_API int __stdcall MV_FG_FlushQueue </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a>&#160;</td>
          <td class="paramname"><em>hStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN <a class="el" href="group___xE6_x9E_x9A_xE4_xB8_xBE_xE7_xB1_xBB_xE5_x9E_x8B_xE5_xAE_x9A_xE4_xB9_x89.html#gae5852b0e56ae9feccef5505206d78562">MV_FG_BUFFER_QUEUE_TYPE</a>&#160;</td>
          <td class="paramname"><em>enQueueType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>刷新缓存队列 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">hStream</td><td>[IN] 流通道句柄 </td></tr>
    <tr><td class="paramname">enQueueType</td><td>[IN] 队列类型 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>成功，返回<a class="el" href="group___xE7_x8A_xB6_xE6_x80_x81_xE7_xA0_x81.html">MV_FG_SUCCESS</a>；失败，返回<a class="el" href="group___xE7_x8A_xB6_xE6_x80_x81_xE7_xA0_x81.html">状态码</a> </dd></dl>
<dl class="section remark"><dt>备注</dt><dd>取流过程中不支持MV_FG_BUFFER_QUEUE_INPUT_TO_OUTPUT、MV_FG_BUFFER_QUEUE_ALL_DISCARD。 </dd></dl>

</div>
</div>
<a id="gac1772dd2bc2a1ddf9fbc28044cd6742a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1772dd2bc2a1ddf9fbc28044cd6742a">&#9670;&nbsp;</a></span>MV_FG_StartAcquisition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_FGCTRL_API int __stdcall MV_FG_StartAcquisition </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a>&#160;</td>
          <td class="paramname"><em>hStream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>开始取流 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">hStream</td><td>[IN] 流通道句柄 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>成功，返回<a class="el" href="group___xE7_x8A_xB6_xE6_x80_x81_xE7_xA0_x81.html">MV_FG_SUCCESS</a>；失败，返回<a class="el" href="group___xE7_x8A_xB6_xE6_x80_x81_xE7_xA0_x81.html">状态码</a> </dd></dl>

</div>
</div>
<a id="ga230e6896d6400514748b593b9d3c704b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga230e6896d6400514748b593b9d3c704b">&#9670;&nbsp;</a></span>MV_FG_StopAcquisition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_FGCTRL_API int __stdcall MV_FG_StopAcquisition </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a>&#160;</td>
          <td class="paramname"><em>hStream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>停止取流 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">hStream</td><td>[IN] 流通道句柄 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>成功，返回<a class="el" href="group___xE7_x8A_xB6_xE6_x80_x81_xE7_xA0_x81.html">MV_FG_SUCCESS</a>；失败，返回<a class="el" href="group___xE7_x8A_xB6_xE6_x80_x81_xE7_xA0_x81.html">状态码</a> </dd></dl>

</div>
</div>
<a id="ga14ab6d598e6b313d373ccc6242c2dfba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14ab6d598e6b313d373ccc6242c2dfba">&#9670;&nbsp;</a></span>MV_FG_GetImageBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_FGCTRL_API int __stdcall MV_FG_GetImageBuffer </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#ga8fc71f0c8b24123c2313e89bb4d05afe">STREAMHANDLE</a>&#160;</td>
          <td class="paramname"><em>hStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#gaeb7de499673b83a2f7956238b5c03271">BUFFERHANDLE</a> *&#160;</td>
          <td class="paramname"><em>phBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN unsigned int&#160;</td>
          <td class="paramname"><em>nTimeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>获取一帧图像的缓存信息（使用 <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#gaa876df36c0ad4be0e2c7184e5076a0c7" title="向流通道中注册缓存（必须在 MV_FG_StartAcquisition() 前注册缓存）">MV_FG_AnnounceBuffer()</a> 注册缓存的取流方式） </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">hStream</td><td>[IN] 流通道句柄 </td></tr>
    <tr><td class="paramname">phBuffer</td><td>[OUT] 缓存句柄 </td></tr>
    <tr><td class="paramname">nTimeout</td><td>[IN] 超时时间，以毫秒为单位 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>成功，返回<a class="el" href="group___xE7_x8A_xB6_xE6_x80_x81_xE7_xA0_x81.html">MV_FG_SUCCESS</a>；失败，返回<a class="el" href="group___xE7_x8A_xB6_xE6_x80_x81_xE7_xA0_x81.html">状态码</a> </dd></dl>
<dl class="section remark"><dt>备注</dt><dd>通过 <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga6984ec4a8ff98ff1257fa5052de01b06" title="通过缓存句柄获取缓存信息">MV_FG_GetBufferInfo()</a> 接口根据缓存句柄获取图像信息。 </dd></dl>

</div>
</div>
<a id="ga6984ec4a8ff98ff1257fa5052de01b06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6984ec4a8ff98ff1257fa5052de01b06">&#9670;&nbsp;</a></span>MV_FG_GetBufferInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_FGCTRL_API int __stdcall MV_FG_GetBufferInfo </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#gaeb7de499673b83a2f7956238b5c03271">BUFFERHANDLE</a>&#160;</td>
          <td class="paramname"><em>hBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT <a class="el" href="struct_m_v___f_g___b_u_f_f_e_r___i_n_f_o.html">MV_FG_BUFFER_INFO</a> *&#160;</td>
          <td class="paramname"><em>pstBufferInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>通过缓存句柄获取缓存信息 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">hBuffer</td><td>[IN] 缓存句柄 </td></tr>
    <tr><td class="paramname">pstBufferInfo</td><td>[OUT] 缓存信息 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>成功，返回<a class="el" href="group___xE7_x8A_xB6_xE6_x80_x81_xE7_xA0_x81.html">MV_FG_SUCCESS</a>；失败，返回<a class="el" href="group___xE7_x8A_xB6_xE6_x80_x81_xE7_xA0_x81.html">状态码</a> </dd></dl>

</div>
</div>
<a id="ga7086bb942615bfeae3078d0342e230de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7086bb942615bfeae3078d0342e230de">&#9670;&nbsp;</a></span>MV_FG_QueueBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MV_FGCTRL_API int __stdcall MV_FG_QueueBuffer </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="group___xE5_xAE_x8F_xE5_xAE_x9A_xE4_xB9_x89.html#gaeb7de499673b83a2f7956238b5c03271">BUFFERHANDLE</a>&#160;</td>
          <td class="paramname"><em>hBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>将图像缓存放回输入队列，用于等待采集图像（图像缓存句柄来自 <a class="el" href="group___xE5_x9B_xBE_xE5_x83_x8F_xE9_x87_x87_xE9_x9B_x86_xE6_x8E_xA5_xE5_x8F_xA3.html#ga14ab6d598e6b313d373ccc6242c2dfba" title="获取一帧图像的缓存信息（使用 MV_FG_AnnounceBuffer() 注册缓存的取流方式）">MV_FG_GetImageBuffer()</a> 接口） </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">hBuffer</td><td>[IN] 缓存句柄 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>成功，返回<a class="el" href="group___xE7_x8A_xB6_xE6_x80_x81_xE7_xA0_x81.html">MV_FG_SUCCESS</a>；失败，返回<a class="el" href="group___xE7_x8A_xB6_xE6_x80_x81_xE7_xA0_x81.html">状态码</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<div class="footer" style="text-align: right;">
	<hr/>
	<small></small>
</div>
</body>
</html>